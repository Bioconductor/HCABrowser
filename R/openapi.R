# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech


#' ApiClient Class
#'
#' Generic API client for OpenAPI client library builds.
#' OpenAPI generic API client. This client handles the client-
#' server communication, and is invariant across implementations. Specifics of
#' the methods and models for each application are generated from the OpenAPI Generator
#' templates.
#'
#' NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
#' Ref: https://openapi-generator.tech
#' Do not edit the class manually.
#'
#' @docType class
#' @title ApiClient
#' @description ApiClient Class
#' @format An \code{R6Class} generator object
#' @field basePath Base url
#' @field userAgent Default user agent
#' @field defaultHeaders
#' @field username Username for HTTP basic authentication
#' @field password Password for HTTP basic authentication
#' @field apiKeys
#' @field accessToken
#' @field timeout Default timeout in seconds
#' @importFrom httr add_headers accept timeout content
#' @export
ApiClient  <- R6::R6Class(
  'ApiClient',
  public = list(
    # base path of all requests
    basePath = "https://dss.data.humancellatlas.org/v1",
    # user agent in the HTTP request
    userAgent = "OpenAPI-Generator/1.0.0/r",
    # default headers in the HTTP request
    defaultHeaders = NULL,
    # username (HTTP basic authentication)
    username = NULL,
    # password (HTTP basic authentication)
    password = NULL,
    # API keys
    apiKeys = NULL,
    # Access token
    accessToken = NULL,
    # Time Out (seconds)
    timeout = NULL,
    # constructor
    initialize = function(basePath=NULL, userAgent=NULL, defaultHeaders=NULL, username=NULL, password=NULL, apiKeys=NULL, accessToken=NULL, timeout=NULL){
      if (!is.null(basePath)) {
        self$basePath <- basePath
      }

      if (!is.null(defaultHeaders)) {
        self$defaultHeaders <- defaultHeaders
      }

      if (!is.null(username)) {
        self$username <- username
      }

      if (!is.null(password)) {
        self$password <- password
      }

      if (!is.null(accessToken)) {
        self$accessToken <- accessToken
      }

      if (!is.null(apiKeys)) {
        self$apiKeys <- apiKeys
      } else {
        self$apiKeys <- list()
      }

      if (!is.null(userAgent)) {
        self$`userAgent` <- userAgent
      }

      if (!is.null(timeout)) {
        self$timeout <- timeout
      }
    },
    CallApi = function(url, method, queryParams, headerParams, body, ...){
      headers <- httr::add_headers(c(headerParams, self$defaultHeaders))

      httpTimeout <- NULL
      if (!is.null(self$timeout)) {
        httpTimeout <- httr::timeout(self$timeout)
      }

      if (method == "GET") {
        httr::GET(url, query = queryParams, headers, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "POST") {
        httr::POST(url, query = queryParams, headers, body = body, httr::content_type("application/json"), httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "PUT") {
        httr::PUT(url, query = queryParams, headers, body = body, httr::content_type("application/json"), httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "PATCH") {
        httr::PATCH(url, query = queryParams, headers, body = body, httr::content_type("application/json"), httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "HEAD") {
        httr::HEAD(url, query = queryParams, headers, httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else if (method == "DELETE") {
        httr::DELETE(url, query = queryParams, headers, httpTimeout, httpTimeout, httr::user_agent(self$`userAgent`), ...)
      } else {
        errMsg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
        stop(errMsg)
      }
    },

    # Deserialize the content of api response to the given type.
    deserialize = function(resp, returnType, pkgEnv) {
      respObj <- jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
      self$deserializeObj(respObj, returnType, pkgEnv)
    },


    # Deserialize the response from jsonlite object based on the given type
    # by handling complex and nested types by iterating recursively
    # Example returnTypes will be like "array[integer]", "map(Pet)", "array[map(Tag)]", etc.,

    deserializeObj = function(obj, returnType, pkgEnv) {
      returnObj <- NULL
      primitiveTypes <- c("character", "numeric", "integer", "logical", "complex")

      # To handle the "map" type 
      if (startsWith(returnType, "map(")) {
        innerReturnType <- regmatches(returnType, regexec(pattern = "map\\((.*)\\)", returnType))[[1]][2]
        returnObj <- lapply(names(obj), function(name) {
          self$deserializeObj(obj[[name]], innerReturnType, pkgEnv)
        })
        names(returnObj) <- names(obj)
      }

      # To handle the "array" type
      else if (startsWith(returnType, "array[")) {
        innerReturnType <- regmatches(returnType, regexec(pattern = "array\\[(.*)\\]", returnType))[[1]][2]
        if (c(innerReturnType) %in% primitiveTypes) {
          returnObj <- vector("list", length = length(obj))
          if (length(obj) > 0) {
            for (row in 1:length(obj)) {
              returnObj[[row]] <- self$deserializeObj(obj[row], innerReturnType, pkgEnv)
            }
          }
        } else {
          returnObj <- vector("list", length = nrow(obj))
          if (nrow(obj) > 0) {
            for (row in 1:nrow(obj)) {
              returnObj[[row]] <- self$deserializeObj(obj[row, , drop = FALSE], innerReturnType, pkgEnv)
            }
          }
        }
      }

      # To handle model objects which are not array or map containers. Ex:"Pet"
      else if (exists(returnType, pkgEnv) && !(c(returnType) %in% primitiveTypes)) {
        returnType <- get(returnType, envir = as.environment(pkgEnv))
        returnObj <- returnType$new()
        returnObj$fromJSON(jsonlite::toJSON(obj, digits = NA))
      } 

      # To handle primitive type
      else {
        returnObj <- obj
      }
      returnObj
    }
  )
)
#' @docType class
#' @title ApiResponse
#' @description ApiResponse Class
#' @format An \code{R6Class} generator object
#' @field content The deserialized response body.
#' @field response The raw response from the endpoint.
#' @export
ApiResponse  <- R6::R6Class(
  'ApiResponse',
  public = list(
    content = NULL,
    response = NULL,
    initialize = function(content, response){
      self$content <- content
      self$response <- response
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Bundle
#' @description Bundle Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#' @field versions    list(character)   
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
Bundle <- R6::R6Class(
  'Bundle',
  public = list(
    `uuid` = NULL,
    `versions` = NULL,
    initialize = function(`uuid`, `versions`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`versions`)) {
        stopifnot(is.vector(`versions`), length(`versions`) != 0)
        sapply(`versions`, function(x) stopifnot(is.character(x)))
        self$`versions` <- `versions`
      }
    },
    toJSON = function() {
      BundleObject <- list()
      if (!is.null(self$`uuid`)) {
        BundleObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`versions`)) {
        BundleObject[['versions']] <-
          self$`versions`
      }

      BundleObject
    },
    fromJSON = function(BundleJson) {
      BundleObject <- jsonlite::fromJSON(BundleJson)
      if (!is.null(BundleObject$`uuid`)) {
        self$`uuid` <- BundleObject$`uuid`
      }
      if (!is.null(BundleObject$`versions`)) {
        self$`versions` <- ApiClient$new()$deserializeObj(BundleObject$`versions`, "array[character]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`versions`)) {
        sprintf(
        '"versions":
           [%s]
        ',
        paste(unlist(lapply(self$`versions`, function(x) paste0('"', x, '"'))), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(BundleJson) {
      BundleObject <- jsonlite::fromJSON(BundleJson)
      self$`uuid` <- BundleObject$`uuid`
      self$`versions` <- ApiClient$new()$deserializeObj(BundleObject$`versions`, "array[character]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title BundleEnumerationResult
#' @description BundleEnumerationResult Class
#' @format An \code{R6Class} generator object
#' @field bundles   \link[HCAClient:BundleEnumerationResult_bundles]{   list(BundleEnumerationResultBundles)   }  [optional]
#'
#' @field event_timestamp   character  [optional]
#'
#' @field has_more   character  [optional]
#'
#' @field link   character  [optional]
#'
#' @field object   character  [optional]
#'
#' @field page_count   integer  [optional]
#'
#' @field per_page   integer  [optional]
#'
#' @field search_after   character  [optional]
#'
#' @field search_prefix   \link[HCAClient:]{  object  }  [optional]
#'
#' @field token   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
BundleEnumerationResult <- R6::R6Class(
  'BundleEnumerationResult',
  public = list(
    `bundles` = NULL,
    `event_timestamp` = NULL,
    `has_more` = NULL,
    `link` = NULL,
    `object` = NULL,
    `page_count` = NULL,
    `per_page` = NULL,
    `search_after` = NULL,
    `search_prefix` = NULL,
    `token` = NULL,
    initialize = function(`bundles`=NULL, `event_timestamp`=NULL, `has_more`=NULL, `link`=NULL, `object`=NULL, `page_count`=NULL, `per_page`=NULL, `search_after`=NULL, `search_prefix`=NULL, `token`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`bundles`)) {
        stopifnot(is.vector(`bundles`), length(`bundles`) != 0)
        sapply(`bundles`, function(x) stopifnot(R6::is.R6(x)))
        self$`bundles` <- `bundles`
      }
      if (!is.null(`event_timestamp`)) {
        stopifnot(is.character(`event_timestamp`), length(`event_timestamp`) == 1)
        self$`event_timestamp` <- `event_timestamp`
      }
      if (!is.null(`has_more`)) {
        self$`has_more` <- `has_more`
      }
      if (!is.null(`link`)) {
        stopifnot(is.character(`link`), length(`link`) == 1)
        self$`link` <- `link`
      }
      if (!is.null(`object`)) {
        stopifnot(is.character(`object`), length(`object`) == 1)
        self$`object` <- `object`
      }
      if (!is.null(`page_count`)) {
        stopifnot(is.numeric(`page_count`), length(`page_count`) == 1)
        self$`page_count` <- `page_count`
      }
      if (!is.null(`per_page`)) {
        stopifnot(is.numeric(`per_page`), length(`per_page`) == 1)
        self$`per_page` <- `per_page`
      }
      if (!is.null(`search_after`)) {
        stopifnot(is.character(`search_after`), length(`search_after`) == 1)
        self$`search_after` <- `search_after`
      }
      if (!is.null(`search_prefix`)) {
        stopifnot(R6::is.R6(`search_prefix`))
        self$`search_prefix` <- `search_prefix`
      }
      if (!is.null(`token`)) {
        stopifnot(is.character(`token`), length(`token`) == 1)
        self$`token` <- `token`
      }
    },
    toJSON = function() {
      BundleEnumerationResultObject <- list()
      if (!is.null(self$`bundles`)) {
        BundleEnumerationResultObject[['bundles']] <-
          lapply(self$`bundles`, function(x) x$toJSON())
      }
      if (!is.null(self$`event_timestamp`)) {
        BundleEnumerationResultObject[['event_timestamp']] <-
          self$`event_timestamp`
      }
      if (!is.null(self$`has_more`)) {
        BundleEnumerationResultObject[['has_more']] <-
          self$`has_more`
      }
      if (!is.null(self$`link`)) {
        BundleEnumerationResultObject[['link']] <-
          self$`link`
      }
      if (!is.null(self$`object`)) {
        BundleEnumerationResultObject[['object']] <-
          self$`object`
      }
      if (!is.null(self$`page_count`)) {
        BundleEnumerationResultObject[['page_count']] <-
          self$`page_count`
      }
      if (!is.null(self$`per_page`)) {
        BundleEnumerationResultObject[['per_page']] <-
          self$`per_page`
      }
      if (!is.null(self$`search_after`)) {
        BundleEnumerationResultObject[['search_after']] <-
          self$`search_after`
      }
      if (!is.null(self$`search_prefix`)) {
        BundleEnumerationResultObject[['search_prefix']] <-
          self$`search_prefix`$toJSON()
      }
      if (!is.null(self$`token`)) {
        BundleEnumerationResultObject[['token']] <-
          self$`token`
      }

      BundleEnumerationResultObject
    },
    fromJSON = function(BundleEnumerationResultJson) {
      BundleEnumerationResultObject <- jsonlite::fromJSON(BundleEnumerationResultJson)
      if (!is.null(BundleEnumerationResultObject$`bundles`)) {
        self$`bundles` <- ApiClient$new()$deserializeObj(BundleEnumerationResultObject$`bundles`, "array[BundleEnumerationResultBundles]", "package:HCAClient")
      }
      if (!is.null(BundleEnumerationResultObject$`event_timestamp`)) {
        self$`event_timestamp` <- BundleEnumerationResultObject$`event_timestamp`
      }
      if (!is.null(BundleEnumerationResultObject$`has_more`)) {
        self$`has_more` <- BundleEnumerationResultObject$`has_more`
      }
      if (!is.null(BundleEnumerationResultObject$`link`)) {
        self$`link` <- BundleEnumerationResultObject$`link`
      }
      if (!is.null(BundleEnumerationResultObject$`object`)) {
        self$`object` <- BundleEnumerationResultObject$`object`
      }
      if (!is.null(BundleEnumerationResultObject$`page_count`)) {
        self$`page_count` <- BundleEnumerationResultObject$`page_count`
      }
      if (!is.null(BundleEnumerationResultObject$`per_page`)) {
        self$`per_page` <- BundleEnumerationResultObject$`per_page`
      }
      if (!is.null(BundleEnumerationResultObject$`search_after`)) {
        self$`search_after` <- BundleEnumerationResultObject$`search_after`
      }
      if (!is.null(BundleEnumerationResultObject$`search_prefix`)) {
        search_prefixObject <- object$new()
        search_prefixObject$fromJSON(jsonlite::toJSON(BundleEnumerationResultObject$search_prefix, auto_unbox = TRUE, digits = NA))
        self$`search_prefix` <- search_prefixObject
      }
      if (!is.null(BundleEnumerationResultObject$`token`)) {
        self$`token` <- BundleEnumerationResultObject$`token`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`bundles`)) {
        sprintf(
        '"bundles":
        [%s]
',
        paste(sapply(self$`bundles`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )},
        if (!is.null(self$`event_timestamp`)) {
        sprintf(
        '"event_timestamp":
          "%s"
                ',
        self$`event_timestamp`
        )},
        if (!is.null(self$`has_more`)) {
        sprintf(
        '"has_more":
          "%s"
                ',
        self$`has_more`
        )},
        if (!is.null(self$`link`)) {
        sprintf(
        '"link":
          "%s"
                ',
        self$`link`
        )},
        if (!is.null(self$`object`)) {
        sprintf(
        '"object":
          "%s"
                ',
        self$`object`
        )},
        if (!is.null(self$`page_count`)) {
        sprintf(
        '"page_count":
          %d
                ',
        self$`page_count`
        )},
        if (!is.null(self$`per_page`)) {
        sprintf(
        '"per_page":
          %d
                ',
        self$`per_page`
        )},
        if (!is.null(self$`search_after`)) {
        sprintf(
        '"search_after":
          "%s"
                ',
        self$`search_after`
        )},
        if (!is.null(self$`search_prefix`)) {
        sprintf(
        '"search_prefix":
        %s
        ',
        jsonlite::toJSON(self$`search_prefix`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`token`)) {
        sprintf(
        '"token":
          "%s"
                ',
        self$`token`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(BundleEnumerationResultJson) {
      BundleEnumerationResultObject <- jsonlite::fromJSON(BundleEnumerationResultJson)
      self$`bundles` <- ApiClient$new()$deserializeObj(BundleEnumerationResultObject$`bundles`, "array[BundleEnumerationResultBundles]","package:HCAClient")
      self$`event_timestamp` <- BundleEnumerationResultObject$`event_timestamp`
      self$`has_more` <- BundleEnumerationResultObject$`has_more`
      self$`link` <- BundleEnumerationResultObject$`link`
      self$`object` <- BundleEnumerationResultObject$`object`
      self$`page_count` <- BundleEnumerationResultObject$`page_count`
      self$`per_page` <- BundleEnumerationResultObject$`per_page`
      self$`search_after` <- BundleEnumerationResultObject$`search_after`
      self$`search_prefix` <- object$new()$fromJSON(jsonlite::toJSON(BundleEnumerationResultObject$search_prefix, auto_unbox = TRUE, digits = NA))
      self$`token` <- BundleEnumerationResultObject$`token`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title BundleEnumerationResultBundles
#' @description BundleEnumerationResultBundles Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
BundleEnumerationResultBundles <- R6::R6Class(
  'BundleEnumerationResultBundles',
  public = list(
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`uuid`, `version`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      BundleEnumerationResultBundlesObject <- list()
      if (!is.null(self$`uuid`)) {
        BundleEnumerationResultBundlesObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        BundleEnumerationResultBundlesObject[['version']] <-
          self$`version`
      }

      BundleEnumerationResultBundlesObject
    },
    fromJSON = function(BundleEnumerationResultBundlesJson) {
      BundleEnumerationResultBundlesObject <- jsonlite::fromJSON(BundleEnumerationResultBundlesJson)
      if (!is.null(BundleEnumerationResultBundlesObject$`uuid`)) {
        self$`uuid` <- BundleEnumerationResultBundlesObject$`uuid`
      }
      if (!is.null(BundleEnumerationResultBundlesObject$`version`)) {
        self$`version` <- BundleEnumerationResultBundlesObject$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(BundleEnumerationResultBundlesJson) {
      BundleEnumerationResultBundlesObject <- jsonlite::fromJSON(BundleEnumerationResultBundlesJson)
      self$`uuid` <- BundleEnumerationResultBundlesObject$`uuid`
      self$`version` <- BundleEnumerationResultBundlesObject$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title BundleFile
#' @description BundleFile Class
#' @format An \code{R6Class} generator object
#' @field indexed   character  
#'
#' @field name   character  
#'
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
BundleFile <- R6::R6Class(
  'BundleFile',
  public = list(
    `indexed` = NULL,
    `name` = NULL,
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`indexed`, `name`, `uuid`, `version`, ...){
      local.optional.var <- list(...)
      if (!missing(`indexed`)) {
        self$`indexed` <- `indexed`
      }
      if (!missing(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      BundleFileObject <- list()
      if (!is.null(self$`indexed`)) {
        BundleFileObject[['indexed']] <-
          self$`indexed`
      }
      if (!is.null(self$`name`)) {
        BundleFileObject[['name']] <-
          self$`name`
      }
      if (!is.null(self$`uuid`)) {
        BundleFileObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        BundleFileObject[['version']] <-
          self$`version`
      }

      BundleFileObject
    },
    fromJSON = function(BundleFileJson) {
      BundleFileObject <- jsonlite::fromJSON(BundleFileJson)
      if (!is.null(BundleFileObject$`indexed`)) {
        self$`indexed` <- BundleFileObject$`indexed`
      }
      if (!is.null(BundleFileObject$`name`)) {
        self$`name` <- BundleFileObject$`name`
      }
      if (!is.null(BundleFileObject$`uuid`)) {
        self$`uuid` <- BundleFileObject$`uuid`
      }
      if (!is.null(BundleFileObject$`version`)) {
        self$`version` <- BundleFileObject$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`indexed`)) {
        sprintf(
        '"indexed":
          "%s"
                ',
        self$`indexed`
        )},
        if (!is.null(self$`name`)) {
        sprintf(
        '"name":
          "%s"
                ',
        self$`name`
        )},
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(BundleFileJson) {
      BundleFileObject <- jsonlite::fromJSON(BundleFileJson)
      self$`indexed` <- BundleFileObject$`indexed`
      self$`name` <- BundleFileObject$`name`
      self$`uuid` <- BundleFileObject$`uuid`
      self$`version` <- BundleFileObject$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title BundleVersion
#' @description BundleVersion Class
#' @format An \code{R6Class} generator object
#' @field creator_uid   integer  [optional]
#'
#' @field files   \link[HCAClient:file_version]{   list(FileVersion)   }  [optional]
#'
#' @field uuid   character  [optional]
#'
#' @field version   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
BundleVersion <- R6::R6Class(
  'BundleVersion',
  public = list(
    `creator_uid` = NULL,
    `files` = NULL,
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`creator_uid`=NULL, `files`=NULL, `uuid`=NULL, `version`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`creator_uid`)) {
        stopifnot(is.numeric(`creator_uid`), length(`creator_uid`) == 1)
        self$`creator_uid` <- `creator_uid`
      }
      if (!is.null(`files`)) {
        stopifnot(is.vector(`files`), length(`files`) != 0)
        sapply(`files`, function(x) stopifnot(R6::is.R6(x)))
        self$`files` <- `files`
      }
      if (!is.null(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!is.null(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      BundleVersionObject <- list()
      if (!is.null(self$`creator_uid`)) {
        BundleVersionObject[['creator_uid']] <-
          self$`creator_uid`
      }
      if (!is.null(self$`files`)) {
        BundleVersionObject[['files']] <-
          lapply(self$`files`, function(x) x$toJSON())
      }
      if (!is.null(self$`uuid`)) {
        BundleVersionObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        BundleVersionObject[['version']] <-
          self$`version`
      }

      BundleVersionObject
    },
    fromJSON = function(BundleVersionJson) {
      BundleVersionObject <- jsonlite::fromJSON(BundleVersionJson)
      if (!is.null(BundleVersionObject$`creator_uid`)) {
        self$`creator_uid` <- BundleVersionObject$`creator_uid`
      }
      if (!is.null(BundleVersionObject$`files`)) {
        self$`files` <- ApiClient$new()$deserializeObj(BundleVersionObject$`files`, "array[FileVersion]", "package:HCAClient")
      }
      if (!is.null(BundleVersionObject$`uuid`)) {
        self$`uuid` <- BundleVersionObject$`uuid`
      }
      if (!is.null(BundleVersionObject$`version`)) {
        self$`version` <- BundleVersionObject$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`creator_uid`)) {
        sprintf(
        '"creator_uid":
          %d
                ',
        self$`creator_uid`
        )},
        if (!is.null(self$`files`)) {
        sprintf(
        '"files":
        [%s]
',
        paste(sapply(self$`files`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )},
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(BundleVersionJson) {
      BundleVersionObject <- jsonlite::fromJSON(BundleVersionJson)
      self$`creator_uid` <- BundleVersionObject$`creator_uid`
      self$`files` <- ApiClient$new()$deserializeObj(BundleVersionObject$`files`, "array[FileVersion]","package:HCAClient")
      self$`uuid` <- BundleVersionObject$`uuid`
      self$`version` <- BundleVersionObject$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Collection
#' @description Collection Class
#' @format An \code{R6Class} generator object
#' @field contents   \link[HCAClient:CollectionItem]{   list(CollectionItem)   }  
#'
#' @field description   character  
#'
#' @field details   \link[HCAClient:]{  object  }  
#'
#' @field name   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
Collection <- R6::R6Class(
  'Collection',
  public = list(
    `contents` = NULL,
    `description` = NULL,
    `details` = NULL,
    `name` = NULL,
    initialize = function(`contents`, `description`, `details`, `name`, ...){
      local.optional.var <- list(...)
      if (!missing(`contents`)) {
        stopifnot(is.vector(`contents`), length(`contents`) != 0)
        sapply(`contents`, function(x) stopifnot(R6::is.R6(x)))
        self$`contents` <- `contents`
      }
      if (!missing(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!missing(`details`)) {
        stopifnot(R6::is.R6(`details`))
        self$`details` <- `details`
      }
      if (!missing(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
    },
    toJSON = function() {
      CollectionObject <- list()
      if (!is.null(self$`contents`)) {
        CollectionObject[['contents']] <-
          lapply(self$`contents`, function(x) x$toJSON())
      }
      if (!is.null(self$`description`)) {
        CollectionObject[['description']] <-
          self$`description`
      }
      if (!is.null(self$`details`)) {
        CollectionObject[['details']] <-
          self$`details`$toJSON()
      }
      if (!is.null(self$`name`)) {
        CollectionObject[['name']] <-
          self$`name`
      }

      CollectionObject
    },
    fromJSON = function(CollectionJson) {
      CollectionObject <- jsonlite::fromJSON(CollectionJson)
      if (!is.null(CollectionObject$`contents`)) {
        self$`contents` <- ApiClient$new()$deserializeObj(CollectionObject$`contents`, "array[CollectionItem]", "package:HCAClient")
      }
      if (!is.null(CollectionObject$`description`)) {
        self$`description` <- CollectionObject$`description`
      }
      if (!is.null(CollectionObject$`details`)) {
        detailsObject <- object$new()
        detailsObject$fromJSON(jsonlite::toJSON(CollectionObject$details, auto_unbox = TRUE, digits = NA))
        self$`details` <- detailsObject
      }
      if (!is.null(CollectionObject$`name`)) {
        self$`name` <- CollectionObject$`name`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`contents`)) {
        sprintf(
        '"contents":
        [%s]
',
        paste(sapply(self$`contents`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )},
        if (!is.null(self$`description`)) {
        sprintf(
        '"description":
          "%s"
                ',
        self$`description`
        )},
        if (!is.null(self$`details`)) {
        sprintf(
        '"details":
        %s
        ',
        jsonlite::toJSON(self$`details`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`name`)) {
        sprintf(
        '"name":
          "%s"
                ',
        self$`name`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(CollectionJson) {
      CollectionObject <- jsonlite::fromJSON(CollectionJson)
      self$`contents` <- ApiClient$new()$deserializeObj(CollectionObject$`contents`, "array[CollectionItem]","package:HCAClient")
      self$`description` <- CollectionObject$`description`
      self$`details` <- object$new()$fromJSON(jsonlite::toJSON(CollectionObject$details, auto_unbox = TRUE, digits = NA))
      self$`name` <- CollectionObject$`name`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title CollectionItem
#' @description CollectionItem Class
#' @format An \code{R6Class} generator object
#' @field path   character  [optional]
#'
#' @field type   character  
#'
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
CollectionItem <- R6::R6Class(
  'CollectionItem',
  public = list(
    `path` = NULL,
    `type` = NULL,
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`type`, `uuid`, `version`, `path`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`type`)) {
        stopifnot(is.character(`type`), length(`type`) == 1)
        self$`type` <- `type`
      }
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
      if (!is.null(`path`)) {
        stopifnot(is.character(`path`), length(`path`) == 1)
        self$`path` <- `path`
      }
    },
    toJSON = function() {
      CollectionItemObject <- list()
      if (!is.null(self$`path`)) {
        CollectionItemObject[['path']] <-
          self$`path`
      }
      if (!is.null(self$`type`)) {
        CollectionItemObject[['type']] <-
          self$`type`
      }
      if (!is.null(self$`uuid`)) {
        CollectionItemObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        CollectionItemObject[['version']] <-
          self$`version`
      }

      CollectionItemObject
    },
    fromJSON = function(CollectionItemJson) {
      CollectionItemObject <- jsonlite::fromJSON(CollectionItemJson)
      if (!is.null(CollectionItemObject$`path`)) {
        self$`path` <- CollectionItemObject$`path`
      }
      if (!is.null(CollectionItemObject$`type`)) {
        self$`type` <- CollectionItemObject$`type`
      }
      if (!is.null(CollectionItemObject$`uuid`)) {
        self$`uuid` <- CollectionItemObject$`uuid`
      }
      if (!is.null(CollectionItemObject$`version`)) {
        self$`version` <- CollectionItemObject$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`path`)) {
        sprintf(
        '"path":
          "%s"
                ',
        self$`path`
        )},
        if (!is.null(self$`type`)) {
        sprintf(
        '"type":
          "%s"
                ',
        self$`type`
        )},
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(CollectionItemJson) {
      CollectionItemObject <- jsonlite::fromJSON(CollectionItemJson)
      self$`path` <- CollectionItemObject$`path`
      self$`type` <- CollectionItemObject$`type`
      self$`uuid` <- CollectionItemObject$`uuid`
      self$`version` <- CollectionItemObject$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title CollectionOfCollectionsItem
#' @description CollectionOfCollectionsItem Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
CollectionOfCollectionsItem <- R6::R6Class(
  'CollectionOfCollectionsItem',
  public = list(
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`uuid`, `version`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      CollectionOfCollectionsItemObject <- list()
      if (!is.null(self$`uuid`)) {
        CollectionOfCollectionsItemObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        CollectionOfCollectionsItemObject[['version']] <-
          self$`version`
      }

      CollectionOfCollectionsItemObject
    },
    fromJSON = function(CollectionOfCollectionsItemJson) {
      CollectionOfCollectionsItemObject <- jsonlite::fromJSON(CollectionOfCollectionsItemJson)
      if (!is.null(CollectionOfCollectionsItemObject$`uuid`)) {
        self$`uuid` <- CollectionOfCollectionsItemObject$`uuid`
      }
      if (!is.null(CollectionOfCollectionsItemObject$`version`)) {
        self$`version` <- CollectionOfCollectionsItemObject$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(CollectionOfCollectionsItemJson) {
      CollectionOfCollectionsItemObject <- jsonlite::fromJSON(CollectionOfCollectionsItemJson)
      self$`uuid` <- CollectionOfCollectionsItemObject$`uuid`
      self$`version` <- CollectionOfCollectionsItemObject$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Default operations
#' @description HCAClient.Default
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ BundlesUuidDelete } \emph{ Delete a bundle or a specific bundle version }
#' Delete the bundle with the given UUID. This deletion is applied across replicas. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject1]{ InlineObject1 }
#' \item \emph{ @param } version character
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : object 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Unauthorized user is attempting this action.
#'
#' \item return type : InlineResponse401 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Unauthorized user is attempting this action.
#'
#' \item return type : InlineResponse403 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Unexpected error
#'
#' \item return type : InlineResponse4091 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault2 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ BundlesUuidGet } \emph{ Retrieve a bundle given a UUID and optionally a version. }
#' Given a bundle UUID, return the latest version of that bundle.  If the version is provided, that version of the bundle is returned instead. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#' \item \emph{ @param } directurls character
#' \item \emph{ @param } presignedurls character
#' \item \emph{ @param } token character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } start.at integer
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_1]{ InlineResponse2001 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse2001 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Pagination \tab  \cr
#' }
#' \item status code : 206 | A single page of results was retrieved.
#'
#' \item return type : InlineResponse2001 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Paginated-Content-Key \tab The JSON response body key containing an array of results that are paginated. \cr
#' X-OpenAPI-Pagination \tab  \cr
#' Link \tab URL to retrieve the next page of results, conforming to [RFC 5988](https://tools.ietf.org/html/rfc5988) The URL in the header refers to the next page of the results to be fetched; if no &#x60;Link rel&#x3D;\&quot;next\&quot;&#x60; URL is included, then all results have been fetched.  \cr
#' }
#' \item status code : 301 | The bundle is still being fetched. The request is being handled asynchronously. The client should follow the redirect after the delay specified in the Retry-After header. 
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds. The client should follow the redirect after waiting for this duration. \cr
#' }
#' \item status code : 400 | Bad request
#'
#' \item return type : InlineResponse400 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#' \item return type : InlineResponse500 
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#' \item return type : InlineResponse503 
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' }
#'
#' \strong{ BundlesUuidPatch } \emph{ Update a bundle. }
#' Add or remove files from a bundle. A specific version of the bundle to update must be provided, and a new version will be written. Bundle manifests exceeding 20,000 files will not be included in the Elasticsearch index document. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject2]{ InlineObject2 }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_3]{ InlineResponse2003 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse2003 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Returned when the server could not process the request due to incorrect inputs.  Examine the code for more details. 
#'
#' \item return type : InlineResponse4002 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Returned when credentials presented do not grant access to this bundle. 
#'
#' \item return type : InlineResponse4031 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Returned when the server could not find the bundle to patch. 
#'
#' \item return type : InlineResponse4041 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 422 | Returned when the server could not find some of the files necessary to complete the operation or if the JSON Pointer reference could not be resolved within the specified file. 
#'
#' \item return type : InlineResponse422 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault3 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ BundlesUuidPut } \emph{ Create a bundle }
#' Create a new version of a bundle with a given UUID.  The list of file UUID and versions to be included must be provided. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } version character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject]{ InlineObject }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_2]{ InlineResponse2002 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse2002 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 201 | OK
#'
#' \item return type : InlineResponse2002 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Returned when the server could not process the request.  Examine the code for more details.
#'
#' \item return type : InlineResponse4001 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Returned when a bundle with the same UUID and version already exists
#'
#' \item return type : InlineResponse409 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault1 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CollectionsPut } \emph{ Create a collection. }
#' Create a new collection. Collections are sets of links to files, bundles, other collections, or fragments of JSON metadata files. Each entry in the input set of links is checked for referential integrity (the link target must exist in the replica referenced). Up to 1000 items can be referenced in a new collection, or added or removed using &#x60;PATCH /collections&#x60;. New collections are private to the authenticated user. Collection items are de-duplicated (if an identical item is given multiple times, it will only be added once). Collections are replicated across storage replicas similarly to files and bundles. 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } version character
#' \item \emph{ @param } json.request.body \link[HCAClient:Collection]{ Collection }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_201]{ InlineResponse201 }   \cr
#'
#'
#' \item status code : 201 | OK
#'
#' \item return type : InlineResponse201 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault6 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CollectionsUuidDelete } \emph{ Delete a collection. }
#' Delete a collection. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#'
#'
#' \item status code : 200 | OK
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault7 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CollectionsUuidGet } \emph{ Retrieve a collection given a UUID. }
#' Given a collection UUID, return the associated collection object.
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_6]{ InlineResponse2006 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse2006 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault5 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CollectionsUuidPatch } \emph{ Update a collection. }
#' Add or remove items from a collection. A specific version of the collection to update must be provided, and a new version will be written. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject4]{ InlineObject4 }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_7]{ InlineResponse2007 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse2007 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Returned when the server could not process the request due to incorrect inputs.  Examine the code for more details. 
#'
#' \item return type : InlineResponse4003 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | Returned when credentials presented do not grant access to this collection. 
#'
#' \item return type : InlineResponse4032 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Returned when the server could not find the collection to patch. 
#'
#' \item return type : InlineResponse4041 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 422 | Returned when the server could not find some of the files necessary to complete the operation or if the JSON Pointer reference could not be resolved within the specified file. 
#'
#' \item return type : InlineResponse422 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault3 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DssApiBundlesCheckoutGet } \emph{ Check the status of a checkout request. }
#' Use this route with the &#x60;checkout_job_id&#x60; identifier returned by &#x60;POST /bundles/{uuid}/checkout&#x60;. 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } checkout.job.id character
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200]{ InlineResponse200 }   \cr
#'
#'
#' \item status code : 200 | Returned when a checkout request for the checkout job id exists.
#'
#' \item return type : InlineResponse200 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Cannot find checkout.
#'
#' \item return type : InlineResponse404 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DssApiBundlesCheckoutPost } \emph{ Check out a bundle to DSS-managed or user-managed cloud object storage destination }
#' Initiate asynchronous checkout of a bundle. The response JSON contains a field, &#x60;checkout_job_id&#x60;, that can be used to query the status of the checkout via the &#x60;GET /bundles/checkout/{checkout_job_id}&#x60; API method. FIXME: document the error code returned when the bundle or specified version does not exist. TODO: After some time period, the data will be removed. TBD: This could be based on initial checkout time or last access time. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject3]{ InlineObject3 }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_4]{ InlineResponse2004 }   \cr
#'
#'
#' \item status code : 200 | Returned when the bundle UUID with optionally specified version exists and checkout has been initiated.
#'
#' \item return type : InlineResponse2004 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault4 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DssApiBundlesEnumerate } \emph{ List through all available bundles. }
#' Lists all the bundles available in the data-store, responses will be returned in a paginated format, at most 500 values shall be returned at a time. Tombstoned bundles will be omitted from the list of bundles available. 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } prefix character
#' \item \emph{ @param } token character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search.after character
#' \item \emph{ @returnType } \link[HCAClient:BundleEnumerationResult]{ BundleEnumerationResult }   \cr
#'
#'
#' \item status code : 200 | All results retrieved.
#'
#' \item return type : BundleEnumerationResult 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Pagination \tab  \cr
#' }
#' \item status code : 206 | A single page of results was retrieved.
#'
#' \item return type : BundleEnumerationResult 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Paginated-Content-Key \tab The JSON response body key containing an array of results that are paginated. \cr
#' X-OpenAPI-Pagination \tab  \cr
#' Link \tab URL to retrieve the next page of results. \cr
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DssApiCollectionsListCollections } \emph{ Retrieve a user&#39;s collections. }
#' Return a list of a user&#39;s collections. Collections are sets of links to files, bundles, other collections, or fragments of JSON metadata files. Each entry in the input set of links is checked for referential integrity (the link target must exist in the replica referenced). Up to 1000 items can be referenced in a new collection, or added or removed using &#x60;PATCH /collections&#x60;. New collections are private to the authenticated user. Collection items are de-duplicated (if an identical item is given multiple times, it will only be added once). Collections are replicated across storage replicas similarly to files and bundles. 
#'
#' \itemize{
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } start.at integer
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_5]{ InlineResponse2005 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse2005 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Pagination \tab  \cr
#' }
#' \item status code : 206 | A single page of results was retrieved.
#'
#' \item return type : InlineResponse2005 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Paginated-Content-Key \tab The JSON response body key containing an array of results that are paginated. \cr
#' X-OpenAPI-Pagination \tab  \cr
#' Link \tab URL to retrieve the next page of results, conforming to [RFC 5988](https://tools.ietf.org/html/rfc5988) The URL in the header refers to the next page of the results to be fetched; if no &#x60;Link rel&#x3D;\&quot;next\&quot;&#x60; URL is included, then all results have been fetched.  \cr
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault5 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DssApiEventsListEvents } \emph{ Replay events }
#' Return urls where event data is available, with manifest of contents. 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } from.date character
#' \item \emph{ @param } to.date character
#' \item \emph{ @param } per.page integer
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_8]{ list(inline_response_200_8) }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : array[InlineResponse2008] 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Pagination \tab  \cr
#' }
#' \item status code : 206 | A single page of results was retrieved.
#'
#' \item return type : array[InlineResponse2008] 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Paginated-Content-Key \tab The JSON response body key containing an array of results that are paginated. \cr
#' X-OpenAPI-Pagination \tab  \cr
#' Link \tab URL to retrieve the next page of results, conforming to [RFC 5988](https://tools.ietf.org/html/rfc5988) The URL in the header refers to the next page of the results to be fetched; if no &#x60;Link rel&#x3D;\&quot;next\&quot;&#x60; URL is included, then all results have been fetched. \cr
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault8 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DssApiSubscriptionsFind } \emph{ Retrieve a user\\&#39;s event subscriptions. }
#' Return a list of associated subscriptions. 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } subscription.type Enum < [elasticsearch, jmespath] > 
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_10]{ InlineResponse20010 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse20010 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault9 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ EventsUuidGet } \emph{ Retrieve a bundle metadata document given a UUID and version. }
#' Given a bundle UUID and version, return the bundle metadata document. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } version character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : object 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault4 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ FilesUuidGet } \emph{ Retrieve a file given a UUID and optionally a version. }
#' Given a file UUID, return the latest version of that file.  If the version is provided, that version of the file is returned instead. Headers will contain the data store metadata for the file. This endpoint returns a HTTP redirect to another HTTP endpoint with the file contents. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#' \item \emph{ @param } token character
#' \item \emph{ @param } directurl character
#' \item \emph{ @param } content.disposition character
#' \item \emph{ @returnType } \link[HCAClient:inline_response_default_4]{ InlineResponseDefault4 }   \cr
#'
#'
#' \item status code : 301 | The file is still being fetched. The request is being handled asynchronously. The client should follow the redirect after the delay specified in the Retry-After header. 
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds. The client should follow the redirect after waiting for this duration. \cr
#' }
#' \item status code : 302 | Redirects to a signed URL with the data.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' X-DSS-CREATOR-UID \tab User ID who created this file. \cr
#' X-DSS-SIZE \tab File size (bytes). \cr
#' X-DSS-SHA256 \tab SHA-256 (in hex format) of the file contents in hex. \cr
#' X-DSS-VERSION \tab Timestamp of file creation in DSS_VERSION format. \cr
#' X-DSS-CONTENT-TYPE \tab Content-type of the file. \cr
#' X-DSS-CRC32C \tab CRC-32C (in hex format) of the file contents in hex. \cr
#' X-DSS-S3-ETAG \tab S3 ETag (in hex format) of the file contents. \cr
#' X-DSS-SHA1 \tab SHA-1 (in hex format) of the file contents in hex. \cr
#' }
#' \item status code : 400 | Bad request
#'
#' \item return type : InlineResponse4004 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault4 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ FilesUuidHead } \emph{ Retrieve a file&#39;s metadata given an UUID and optionally a version. }
#' Given a file UUID, return the metadata for the latest version of that file.  If the version is provided, that version&#39;s metadata is returned instead.  The metadata is returned in the headers. NOTE When using the HCA CLI, this will stream the file to stdout and may need to be piped.  For example,   &#x60;hca dss get-file --uuid UUID --replica aws &gt; result.txt&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } version character
#'
#'
#' \item status code : 200 | Returns metadata
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' X-DSS-CREATOR-UID \tab User ID who created this file. \cr
#' X-DSS-SIZE \tab File size (bytes). \cr
#' X-DSS-SHA256 \tab SHA-256 (in hex format) of the file contents in hex. \cr
#' X-DSS-VERSION \tab Timestamp of file creation in DSS_VERSION format. \cr
#' X-DSS-CONTENT-TYPE \tab Content-type of the file. \cr
#' X-DSS-CRC32C \tab CRC-32C (in hex format) of the file contents in hex. \cr
#' X-DSS-S3-ETAG \tab S3 ETag (in hex format) of the file contents. \cr
#' X-DSS-SHA1 \tab SHA-1 (in hex format) of the file contents in hex. \cr
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' }
#'
#' \strong{ FilesUuidPut } \emph{ Create a new version of a file }
#' Create a new version of a file with a given UUID. The contents of the file are provided by the client by reference using a cloud object storage URL. The file on the cloud object storage service must have metadata set listing the file checksums and content-type. The metadata fields required are: - hca-dss-sha256: SHA-256 checksum of the file - hca-dss-sha1: SHA-1 checksum of the file - hca-dss-s3_etag: S3 ETAG checksum of the file.  See https://stackoverflow.com/q/12186993 for the general algorithm for how checksum is calculated.  For files smaller than 64MB, this is the MD5 checksum of the file.  For files larger than 64MB but smaller than 640,000MB, we use 64MB chunks.  For files larger than 640,000MB, we use a chunk size equal to the total file size divided by 10000, rounded up to the nearest MB. MB, in this section, refers to 1,048,576 bytes.  Note that 640,000MB is not the same as 640GB! - hca-dss-crc32c: CRC-32C checksum of the file 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } version character
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject5]{ InlineObject5 }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_9]{ InlineResponse2009 }   \cr
#'
#'
#' \item status code : 200 | Returned when the file is already present and is identical to the file being uploaded.
#'
#' \item return type : InlineResponse2009 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 201 | Returned when the file is successfully copied.
#'
#' \item return type : InlineResponse2009 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 202 | Returned when the file has been queued up for copying.
#'
#' \item return type : InlineResponse202 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Returned when the server could not process the request.  Examine the code for more details.
#'
#' \item return type : InlineResponse4005 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 409 | Returned when a file with the same UUID and version already exists
#'
#' \item return type : InlineResponse4092 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 422 | Returned when a request cannot be processed due to invalid values in a supplied entity.
#'
#' \item return type : InlineResponse4221 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault1 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SearchPost } \emph{ Find bundles by searching their metadata with an Elasticsearch query  }
#' Accepts Elasticsearch JSON query and returns matching bundle identifiers # Index design The metadata seach index is implemented as a [document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database) using [Elasticsearch](https://www.elastic.co/). The index stores all information relevant to a bundle within each bundle document, largely eliminating the need for [object-relational mapping](https://en.wikipedia.org/wiki/Object-relational_mapping). This design is optimized for queries that filter the data.  To illustrate this concept, say our index stored information on three entities, &#x60;foo&#x60;, &#x60;bar&#x60;, and &#x60;baz&#x60;. A foo can have many bars and bars can have many bazes. If we were to index bazes in a document-oriented design, the information on the foo a bar comes from and the bazes it contains are combined into a single document. A example sketch of this is shown below in [JSON-schema](https://en.wikipedia.org/wiki/JSON#JSON_Schema). &#x60;&#x60;&#x60; {   \&quot;definitions\&quot;: {     \&quot;bar\&quot;: {       \&quot;type\&quot;: \&quot;object\&quot;,       \&quot;properties\&quot;: {         \&quot;uuid\&quot;: {           \&quot;type\&quot;: \&quot;string\&quot;,           \&quot;format\&quot;: \&quot;uuid\&quot;         },         \&quot;foo\&quot;: {           \&quot;type\&quot;: \&quot;object\&quot;,           \&quot;properties\&quot;: {             \&quot;uuid\&quot;: {               \&quot;type\&quot;: \&quot;string\&quot;,               \&quot;format\&quot;: \&quot;uuid\&quot;             },             ...           }         },         \&quot;bazes\&quot;: {           \&quot;type\&quot;: \&quot;array\&quot;,           \&quot;items\&quot;: {             \&quot;type\&quot;: \&quot;string\&quot;,             \&quot;format\&quot;: \&quot;uuid\&quot;           }         },         ...       }     }   } } &#x60;&#x60;&#x60; This closely resembles the structure of DSS bundle documents: projects have many bundles and bundles have many files. Each bundle document is a concatenation of the metadata on the project it belongs to and the files it contains. # Limitations to index design There are limitations to the design of DSS&#39;s metadata search index. A few important ones are listed below. * [Joins](https://en.wikipedia.org/wiki/Join_(SQL)) between bundle metadata must be conducted client-side * Querying is schema-specific; fields or values changed between schema version will break queries that use those fields and values * A new search index must be built for each schema version * A lot of metadata is duplicated between documents 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject6]{ InlineObject6 }
#' \item \emph{ @param } output.format Enum < [summary, raw] > 
#' \item \emph{ @param } per.page integer
#' \item \emph{ @param } search.after character
#' \item \emph{ @returnType } \link[HCAClient:SearchResult]{ SearchResult }   \cr
#'
#'
#' \item status code : 200 | All results retrieved.
#'
#' \item return type : SearchResult 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Pagination \tab  \cr
#' }
#' \item status code : 206 | A single page of results was retrieved.
#'
#' \item return type : SearchResult 
#' \item response headers :
#'
#' \tabular{ll}{
#' X-OpenAPI-Paginated-Content-Key \tab The JSON response body key containing an array of results that are paginated. \cr
#' X-OpenAPI-Pagination \tab  \cr
#' Link \tab URL to retrieve the next page of results. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : Error 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SubscriptionsPut } \emph{ Create an event subscription. }
#' Register an HTTP endpoint that is to be notified when a given event occurs. Each user is allowed 100 subscriptions, a limit that may be increased in the future. Concerns about notification service limitations should be routed to the DSS development team. 
#'
#' \itemize{
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } json.request.body \link[HCAClient:InlineObject7]{ InlineObject7 }
#' \item \emph{ @returnType } \link[HCAClient:inline_response_201_1]{ InlineResponse2011 }   \cr
#'
#'
#' \item status code : 201 | OK
#'
#' \item return type : InlineResponse2011 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault10 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SubscriptionsUuidDelete } \emph{ Delete an event subscription. }
#' Delete a registered event subscription. The associated query will no longer trigger a callback if a matching document is added to the system. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } subscription.type Enum < [elasticsearch, jmespath] > 
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_12]{ InlineResponse20012 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse20012 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault7 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SubscriptionsUuidGet } \emph{ Retrieve an event subscription given a UUID. }
#' Given a subscription UUID, return the associated subscription. 
#'
#' \itemize{
#' \item \emph{ @param } uuid character
#' \item \emph{ @param } replica Enum < [aws, gcp] > 
#' \item \emph{ @param } subscription.type Enum < [elasticsearch, jmespath] > 
#' \item \emph{ @returnType } \link[HCAClient:inline_response_200_11]{ InlineResponse20011 }   \cr
#'
#'
#' \item status code : 200 | OK
#'
#' \item return type : InlineResponse20011 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Server Error.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 502 | Bad Gateway.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 503 | Service Unavailable.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 504 | Gateway Timeout.
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' Retry-After \tab Delay in seconds, service clients should retry after the delay. \cr
#' }
#' \item status code : 0 | Unexpected error
#'
#' \item return type : InlineResponseDefault5 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \donttest{
#' ####################  BundlesUuidDelete  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the bundle.
#' var.replica <- 'replica_example' # character | Replica to write to.
#' var.json.request.body <- InlineObject1$new() # InlineObject1 | 
#' var.version <- 'version_example' # character | Timestamp of bundle creation in DSS_VERSION format.
#'
#' #Delete a bundle or a specific bundle version
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$BundlesUuidDelete(var.uuid, var.replica, var.json.request.body, version=var.version)
#'
#'
#' ####################  BundlesUuidGet  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | Bundle unique ID.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.version <- 'version_example' # character | Timestamp of bundle creation in DSS_VERSION format.
#' var.directurls <- 'directurls_example' # character | When set to true, the response will contain API-specific URLs that are tied to the specified replica, for example `gs://bucket/object` or `s3://bucket/object`  This parameter is mutually exclusive with the presigned urls parameter. The use of presigned URLs is recommended for data access. Cloud native URLs are currently provided for a limited set of use cases and may not be provided in the future. If cloud native URLs are required, please contact the data store team regarding the credentials necessary to use them. 
#' var.presignedurls <- 'presignedurls_example' # character | Include presigned URLs in the response.  This is mutually exclusive with the directurls parameter. 
#' var.token <- 'token_example' # character | Token to manage retries.  End users constructing queries should not set this parameter.
#' var.per.page <- 500 # integer | Max number of results to return per page.
#' var.start.at <- 56 # integer | An internal state pointer parameter for use with pagination. This parameter is referenced by the `Link` header as described in the \"Pagination\" section. The API client should not need to set this parameter directly; it should instead directly fetch the URL given in the `Link` header. 
#'
#' #Retrieve a bundle given a UUID and optionally a version.
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$BundlesUuidGet(var.uuid, var.replica, version=var.version, directurls=var.directurls, presignedurls=var.presignedurls, token=var.token, per.page=var.per.page, start.at=var.start.at)
#'
#'
#' ####################  BundlesUuidPatch  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID of the bundle to update.
#' var.replica <- 'replica_example' # character | Replica to update the bundle on. Updates are propagated to other replicas.
#' var.version <- 'version_example' # character | Timestamp of the bundle to update in DSS_VERSION format format (required). 
#' var.json.request.body <- InlineObject2$new() # InlineObject2 | 
#'
#' #Update a bundle.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$BundlesUuidPatch(var.uuid, var.replica, var.version, var.json.request.body)
#'
#'
#' ####################  BundlesUuidPut  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the bundle.
#' var.version <- 'version_example' # character | Timestamp of bundle creation in DSS_VERSION format.
#' var.replica <- 'replica_example' # character | Replica to write to.
#' var.json.request.body <- InlineObject$new() # InlineObject | 
#'
#' #Create a bundle
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$BundlesUuidPut(var.uuid, var.version, var.replica, var.json.request.body)
#'
#'
#' ####################  CollectionsPut  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to write to.
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the collection.
#' var.version <- 'version_example' # character | Timestamp of collection creation in DSS_VERSION format.
#' var.json.request.body <- Collection$new() # Collection | 
#'
#' #Create a collection.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$CollectionsPut(var.replica, var.uuid, var.version, var.json.request.body)
#'
#'
#' ####################  CollectionsUuidDelete  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the collection.
#' var.replica <- 'replica_example' # character | Replica to delete from.
#'
#' #Delete a collection.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$CollectionsUuidDelete(var.uuid, var.replica)
#'
#'
#' ####################  CollectionsUuidGet  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the collection.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.version <- 'version_example' # character | Timestamp of collection creation in DSS_VERSION format.  If this is not provided, the latest version is returned. 
#'
#' #Retrieve a collection given a UUID.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$CollectionsUuidGet(var.uuid, var.replica, version=var.version)
#'
#'
#' ####################  CollectionsUuidPatch  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID of the collection to update.
#' var.replica <- 'replica_example' # character | Replica to update the collection on. Updates are propagated to other replicas.
#' var.version <- 'version_example' # character | Timestamp of the collection to update in DSS_VERSION format format (required). 
#' var.json.request.body <- InlineObject4$new() # InlineObject4 | 
#'
#' #Update a collection.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$CollectionsUuidPatch(var.uuid, var.replica, var.version, var.json.request.body)
#'
#'
#' ####################  DssApiBundlesCheckoutGet  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.checkout.job.id <- 'checkout.job.id_example' # character | A RFC4122-compliant ID for the checkout job request.
#'
#' #Check the status of a checkout request.
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$DssApiBundlesCheckoutGet(var.replica, var.checkout.job.id)
#'
#'
#' ####################  DssApiBundlesCheckoutPost  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the bundle.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.version <- 'version_example' # character | Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.
#' var.json.request.body <- InlineObject3$new() # InlineObject3 | 
#'
#' #Check out a bundle to DSS-managed or user-managed cloud object storage destination
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$DssApiBundlesCheckoutPost(var.uuid, var.replica, version=var.version, json.request.body=var.json.request.body)
#'
#'
#' ####################  DssApiBundlesEnumerate  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.prefix <- 'prefix_example' # character | Is used to specify the beginning of a particular bundle UUID. Specifying a character(s) would provide all avaliable bundles starting with that character(s).
#' var.token <- 'token_example' # character | Token to manage retries.  End users constructing queries should not set this parameter.
#' var.per.page <- 100 # integer | Max number of results to return per page.
#' var.search.after <- 'search.after_example' # character | **Search-After-Context**. An internal state pointer parameter for use with pagination. This parameter is referenced by the `Link` header as described in the \"Pagination\" section. The API client should not need to set this parameter directly; it should instead directly fetch the URL given in the `Link` header. 
#'
#' #List through all available bundles.
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$DssApiBundlesEnumerate(var.replica, prefix=var.prefix, token=var.token, per.page=var.per.page, search.after=var.search.after)
#'
#'
#' ####################  DssApiCollectionsListCollections  ####################
#'
#' library(HCAClient)
#' var.per.page <- 500 # integer | Max number of results to return per page.
#' var.start.at <- 56 # integer | An internal state pointer parameter for use with pagination. This parameter is referenced by the `Link` header as described in the \"Pagination\" section. The API client should not need to set this parameter directly; it should instead directly fetch the URL given in the `Link` header. 
#'
#' #Retrieve a user's collections.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$DssApiCollectionsListCollections(per.page=var.per.page, start.at=var.start.at)
#'
#'
#' ####################  DssApiEventsListEvents  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.from.date <- 'from.date_example' # character | Timestamp to begin replaying events, in DSS_VERSION format.  If this is not provided, replay from the earliest event.
#' var.to.date <- 'to.date_example' # character | Timestamp to stop replaying events, in DSS_VERSION format.  If this is not provided, replay to the latest event.
#' var.per.page <- 1 # integer | Max number of results to return per page.
#'
#' #Replay events
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$DssApiEventsListEvents(var.replica, from.date=var.from.date, to.date=var.to.date, per.page=var.per.page)
#'
#'
#' ####################  DssApiSubscriptionsFind  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.subscription.type <- 'jmespath' # character | Type of subscriptions to fetch (elasticsearch or jmespath).
#'
#' #Retrieve a user\\'s event subscriptions.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$DssApiSubscriptionsFind(var.replica, subscription.type=var.subscription.type)
#'
#'
#' ####################  EventsUuidGet  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | Bundle unique ID.
#' var.version <- 'version_example' # character | Timestamp of bundle creation in DSS_VERSION format.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#'
#' #Retrieve a bundle metadata document given a UUID and version.
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$EventsUuidGet(var.uuid, var.version, var.replica)
#'
#'
#' ####################  FilesUuidGet  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the file.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.version <- 'version_example' # character | Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.
#' var.token <- 'token_example' # character | Token to manage retries.  End users constructing queries should not set this parameter.
#' var.directurl <- 'directurl_example' # character | When set to true, the response will contain API-specific URLs that are tied to the specified replica, for example `gs://bucket/object` or `s3://bucket/object`  The use of presigned URLs is recommended for data access. Cloud native URLs are currently provided for a limited set of use cases and may not be provided in the future. If cloud native URLs are required, please contact the data store team regarding the credentials necessary to use them. 
#' var.content.disposition <- 'content.disposition_example' # character | Optional and does not work when directurl=true (only works with the default presigned url response).  If this parameter is provided, the response from fetching the returned presigned url will include the specified Content-Disposition header.  This can be useful to indicate to a browser that a file should be downloaded rather than opened in a new tab, and can also supply the original filename in the response.  Example:      content_disposition=\"attachment; filename=data.json\" 
#'
#' #Retrieve a file given a UUID and optionally a version.
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$FilesUuidGet(var.uuid, var.replica, version=var.version, token=var.token, directurl=var.directurl, content.disposition=var.content.disposition)
#'
#'
#' ####################  FilesUuidHead  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the file.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.version <- 'version_example' # character | Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.
#'
#' #Retrieve a file's metadata given an UUID and optionally a version.
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$FilesUuidHead(var.uuid, var.replica, version=var.version)
#'
#'
#' ####################  FilesUuidPut  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the file.
#' var.version <- 'version_example' # character | Timestamp of file creation in DSS_VERSION format.  If this is not provided, the latest version is returned.
#' var.json.request.body <- InlineObject5$new() # InlineObject5 | 
#'
#' #Create a new version of a file
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$FilesUuidPut(var.uuid, var.version, var.json.request.body)
#'
#'
#' ####################  SearchPost  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to search.
#' var.json.request.body <- InlineObject6$new() # InlineObject6 | 
#' var.output.format <- 'summary' # character | Specifies the output format. The default format, `summary`, is a list of UUIDs for bundles that match the query. Set this parameter to `raw` to get the verbatim JSON metadata for bundles that match the query. When using `output_format raw` the `per_page` size is limit to no more than 10 to avoid excessively large response sizes. 
#' var.per.page <- 100 # integer | Max number of results to return per page. When using `output_format raw` the `per_page` size is limit to no more than 10 to avoid excessively large response sizes.
#' var.search.after <- 'search.after_example' # character | **Search-After-Context**. An internal state pointer parameter for use with pagination. This parameter is referenced by the `Link` header as described in the \"Pagination\" section. The API client should not need to set this parameter directly; it should instead directly fetch the URL given in the `Link` header. 
#'
#' #Find bundles by searching their metadata with an Elasticsearch query 
#' api.instance <- DefaultApi$new()
#'
#' result <- api.instance$SearchPost(var.replica, var.json.request.body, output.format=var.output.format, per.page=var.per.page, search.after=var.search.after)
#'
#'
#' ####################  SubscriptionsPut  ####################
#'
#' library(HCAClient)
#' var.replica <- 'replica_example' # character | Replica to write to.
#' var.json.request.body <- InlineObject7$new() # InlineObject7 | 
#'
#' #Create an event subscription.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$SubscriptionsPut(var.replica, var.json.request.body)
#'
#'
#' ####################  SubscriptionsUuidDelete  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the subscription.
#' var.replica <- 'replica_example' # character | Replica to delete from.
#' var.subscription.type <- 'jmespath' # character | type of subscriptions to fetch (elasticsearch or jmespath)
#'
#' #Delete an event subscription.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$SubscriptionsUuidDelete(var.uuid, var.replica, subscription.type=var.subscription.type)
#'
#'
#' ####################  SubscriptionsUuidGet  ####################
#'
#' library(HCAClient)
#' var.uuid <- 'uuid_example' # character | A RFC4122-compliant ID for the subscription.
#' var.replica <- 'replica_example' # character | Replica to fetch from.
#' var.subscription.type <- 'jmespath' # character | type of subscriptions to fetch (elasticsearch or jmespath)
#'
#' #Retrieve an event subscription given a UUID.
#' api.instance <- DefaultApi$new()
#'
#' # Configure OAuth2 access token for authorization: dcpAuth
#' api.instance$apiClient$accessToken <- 'TODO_YOUR_ACCESS_TOKEN';
#'
#' result <- api.instance$SubscriptionsUuidGet(var.uuid, var.replica, subscription.type=var.subscription.type)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom caTools base64encode
#' @export
DefaultApi <- R6::R6Class(
  'DefaultApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    BundlesUuidDelete = function(uuid, replica, json.request.body, version=NULL, ...){
      apiResponse <- self$BundlesUuidDeleteWithHttpInfo(uuid, replica, json.request.body, version, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    BundlesUuidDeleteWithHttpInfo = function(uuid, replica, json.request.body, version=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['replica'] <- replica

      queryParams['version'] <- version

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/bundles/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "object", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    BundlesUuidGet = function(uuid, replica, version=NULL, directurls=NULL, presignedurls=NULL, token=NULL, per.page=500, start.at=NULL, ...){
      apiResponse <- self$BundlesUuidGetWithHttpInfo(uuid, replica, version, directurls, presignedurls, token, per.page, start.at, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    BundlesUuidGetWithHttpInfo = function(uuid, replica, version=NULL, directurls=NULL, presignedurls=NULL, token=NULL, per.page=500, start.at=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['version'] <- version

      queryParams['replica'] <- replica

      queryParams['directurls'] <- directurls

      queryParams['presignedurls'] <- presignedurls

      queryParams['token'] <- token

      queryParams['per_page'] <- per.page

      queryParams['start_at'] <- start.at

      urlPath <- "/bundles/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2001", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    BundlesUuidPatch = function(uuid, replica, version, json.request.body, ...){
      apiResponse <- self$BundlesUuidPatchWithHttpInfo(uuid, replica, version, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    BundlesUuidPatchWithHttpInfo = function(uuid, replica, version, json.request.body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['replica'] <- replica

      queryParams['version'] <- version

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/bundles/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2003", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    BundlesUuidPut = function(uuid, version, replica, json.request.body, ...){
      apiResponse <- self$BundlesUuidPutWithHttpInfo(uuid, version, replica, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    BundlesUuidPutWithHttpInfo = function(uuid, version, replica, json.request.body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['version'] <- version

      queryParams['replica'] <- replica

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/bundles/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2002", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CollectionsPut = function(replica, uuid, version, json.request.body, ...){
      apiResponse <- self$CollectionsPutWithHttpInfo(replica, uuid, version, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CollectionsPutWithHttpInfo = function(replica, uuid, version, json.request.body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['replica'] <- replica

      queryParams['uuid'] <- uuid

      queryParams['version'] <- version

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/collections"
      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse201", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CollectionsUuidDelete = function(uuid, replica, ...){
      apiResponse <- self$CollectionsUuidDeleteWithHttpInfo(uuid, replica, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CollectionsUuidDeleteWithHttpInfo = function(uuid, replica, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      urlPath <- "/collections/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CollectionsUuidGet = function(uuid, replica, version=NULL, ...){
      apiResponse <- self$CollectionsUuidGetWithHttpInfo(uuid, replica, version, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CollectionsUuidGetWithHttpInfo = function(uuid, replica, version=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['version'] <- version

      urlPath <- "/collections/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2006", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CollectionsUuidPatch = function(uuid, replica, version, json.request.body, ...){
      apiResponse <- self$CollectionsUuidPatchWithHttpInfo(uuid, replica, version, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CollectionsUuidPatchWithHttpInfo = function(uuid, replica, version, json.request.body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['replica'] <- replica

      queryParams['version'] <- version

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/collections/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2007", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DssApiBundlesCheckoutGet = function(replica, checkout.job.id, ...){
      apiResponse <- self$DssApiBundlesCheckoutGetWithHttpInfo(replica, checkout.job.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DssApiBundlesCheckoutGetWithHttpInfo = function(replica, checkout.job.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`checkout.job.id`)) {
        stop("Missing required parameter `checkout.job.id`.")
      }

      queryParams['replica'] <- replica

      urlPath <- "/bundles/checkout/{checkout_job_id}"
      if (!missing(`checkout.job.id`)) {
        urlPath <- gsub(paste0("\\{", "checkout_job_id", "\\}"), URLencode(as.character(`checkout.job.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse200", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DssApiBundlesCheckoutPost = function(uuid, replica, version=NULL, json.request.body=NULL, ...){
      apiResponse <- self$DssApiBundlesCheckoutPostWithHttpInfo(uuid, replica, version, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DssApiBundlesCheckoutPostWithHttpInfo = function(uuid, replica, version=NULL, json.request.body=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['version'] <- version

      queryParams['replica'] <- replica

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/bundles/{uuid}/checkout"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2004", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DssApiBundlesEnumerate = function(replica, prefix=NULL, token=NULL, per.page=100, search.after=NULL, ...){
      apiResponse <- self$DssApiBundlesEnumerateWithHttpInfo(replica, prefix, token, per.page, search.after, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DssApiBundlesEnumerateWithHttpInfo = function(replica, prefix=NULL, token=NULL, per.page=100, search.after=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['prefix'] <- prefix

      queryParams['token'] <- token

      queryParams['per_page'] <- per.page

      queryParams['search_after'] <- search.after

      urlPath <- "/bundles/all"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BundleEnumerationResult", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DssApiCollectionsListCollections = function(per.page=500, start.at=NULL, ...){
      apiResponse <- self$DssApiCollectionsListCollectionsWithHttpInfo(per.page, start.at, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DssApiCollectionsListCollectionsWithHttpInfo = function(per.page=500, start.at=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['per_page'] <- per.page

      queryParams['start_at'] <- start.at

      urlPath <- "/collections"
      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2005", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DssApiEventsListEvents = function(replica, from.date=NULL, to.date=NULL, per.page=1, ...){
      apiResponse <- self$DssApiEventsListEventsWithHttpInfo(replica, from.date, to.date, per.page, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DssApiEventsListEventsWithHttpInfo = function(replica, from.date=NULL, to.date=NULL, per.page=1, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['from_date'] <- from.date

      queryParams['to_date'] <- to.date

      queryParams['replica'] <- replica

      queryParams['per_page'] <- per.page

      urlPath <- "/events"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "array[InlineResponse2008]", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DssApiSubscriptionsFind = function(replica, subscription.type='jmespath', ...){
      apiResponse <- self$DssApiSubscriptionsFindWithHttpInfo(replica, subscription.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DssApiSubscriptionsFindWithHttpInfo = function(replica, subscription.type='jmespath', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['subscription_type'] <- subscription.type

      urlPath <- "/subscriptions"
      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse20010", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    EventsUuidGet = function(uuid, version, replica, ...){
      apiResponse <- self$EventsUuidGetWithHttpInfo(uuid, version, replica, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    EventsUuidGetWithHttpInfo = function(uuid, version, replica, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['version'] <- version

      queryParams['replica'] <- replica

      urlPath <- "/events/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "object", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    FilesUuidGet = function(uuid, replica, version=NULL, token=NULL, directurl=NULL, content.disposition=NULL, ...){
      apiResponse <- self$FilesUuidGetWithHttpInfo(uuid, replica, version, token, directurl, content.disposition, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    FilesUuidGetWithHttpInfo = function(uuid, replica, version=NULL, token=NULL, directurl=NULL, content.disposition=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['version'] <- version

      queryParams['token'] <- token

      queryParams['directurl'] <- directurl

      queryParams['content_disposition'] <- content.disposition

      urlPath <- "/files/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponseDefault4", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    FilesUuidHead = function(uuid, replica, version=NULL, ...){
      apiResponse <- self$FilesUuidHeadWithHttpInfo(uuid, replica, version, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    FilesUuidHeadWithHttpInfo = function(uuid, replica, version=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['version'] <- version

      urlPath <- "/files/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "HEAD",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        ApiResponse$new(NULL, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    FilesUuidPut = function(uuid, version, json.request.body, ...){
      apiResponse <- self$FilesUuidPutWithHttpInfo(uuid, version, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    FilesUuidPutWithHttpInfo = function(uuid, version, json.request.body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`version`)) {
        stop("Missing required parameter `version`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['version'] <- version

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/files/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2009", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SearchPost = function(replica, json.request.body, output.format='summary', per.page=100, search.after=NULL, ...){
      apiResponse <- self$SearchPostWithHttpInfo(replica, json.request.body, output.format, per.page, search.after, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SearchPostWithHttpInfo = function(replica, json.request.body, output.format='summary', per.page=100, search.after=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['output_format'] <- output.format

      queryParams['replica'] <- replica

      queryParams['per_page'] <- per.page

      queryParams['search_after'] <- search.after

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/search"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "SearchResult", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SubscriptionsPut = function(replica, json.request.body, ...){
      apiResponse <- self$SubscriptionsPutWithHttpInfo(replica, json.request.body, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SubscriptionsPutWithHttpInfo = function(replica, json.request.body, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      if (missing(`json.request.body`)) {
        stop("Missing required parameter `json.request.body`.")
      }

      queryParams['replica'] <- replica

      if (!missing(`json.request.body`)) {
        body <- `json.request.body`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/subscriptions"
      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PUT",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse2011", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SubscriptionsUuidDelete = function(uuid, replica, subscription.type='jmespath', ...){
      apiResponse <- self$SubscriptionsUuidDeleteWithHttpInfo(uuid, replica, subscription.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SubscriptionsUuidDeleteWithHttpInfo = function(uuid, replica, subscription.type='jmespath', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['subscription_type'] <- subscription.type

      urlPath <- "/subscriptions/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse20012", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SubscriptionsUuidGet = function(uuid, replica, subscription.type='jmespath', ...){
      apiResponse <- self$SubscriptionsUuidGetWithHttpInfo(uuid, replica, subscription.type, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SubscriptionsUuidGetWithHttpInfo = function(uuid, replica, subscription.type='jmespath', ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`uuid`)) {
        stop("Missing required parameter `uuid`.")
      }

      if (missing(`replica`)) {
        stop("Missing required parameter `replica`.")
      }

      queryParams['replica'] <- replica

      queryParams['subscription_type'] <- subscription.type

      urlPath <- "/subscriptions/{uuid}"
      if (!missing(`uuid`)) {
        urlPath <- gsub(paste0("\\{", "uuid", "\\}"), URLencode(as.character(`uuid`), reserved = TRUE), urlPath)
      }

      # OAuth token
      headerParams['Authorization'] <- paste("Bearer", self$apiClient$accessToken, sep=" ")

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "InlineResponse20011", "package:HCAClient"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Error
#' @description Error Class
#' @format An \code{R6Class} generator object
#' @field code   character  [optional]
#'
#' @field stacktrace   character  [optional]
#'
#' @field status   integer  [optional]
#'
#' @field title   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
Error <- R6::R6Class(
  'Error',
  public = list(
    `code` = NULL,
    `stacktrace` = NULL,
    `status` = NULL,
    `title` = NULL,
    initialize = function(`title`, `code`=NULL, `stacktrace`=NULL, `status`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`title`)) {
        stopifnot(is.character(`title`), length(`title`) == 1)
        self$`title` <- `title`
      }
      if (!is.null(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`stacktrace`)) {
        stopifnot(is.character(`stacktrace`), length(`stacktrace`) == 1)
        self$`stacktrace` <- `stacktrace`
      }
      if (!is.null(`status`)) {
        stopifnot(is.numeric(`status`), length(`status`) == 1)
        self$`status` <- `status`
      }
    },
    toJSON = function() {
      ErrorObject <- list()
      if (!is.null(self$`code`)) {
        ErrorObject[['code']] <-
          self$`code`
      }
      if (!is.null(self$`stacktrace`)) {
        ErrorObject[['stacktrace']] <-
          self$`stacktrace`
      }
      if (!is.null(self$`status`)) {
        ErrorObject[['status']] <-
          self$`status`
      }
      if (!is.null(self$`title`)) {
        ErrorObject[['title']] <-
          self$`title`
      }

      ErrorObject
    },
    fromJSON = function(ErrorJson) {
      ErrorObject <- jsonlite::fromJSON(ErrorJson)
      if (!is.null(ErrorObject$`code`)) {
        self$`code` <- ErrorObject$`code`
      }
      if (!is.null(ErrorObject$`stacktrace`)) {
        self$`stacktrace` <- ErrorObject$`stacktrace`
      }
      if (!is.null(ErrorObject$`status`)) {
        self$`status` <- ErrorObject$`status`
      }
      if (!is.null(ErrorObject$`title`)) {
        self$`title` <- ErrorObject$`title`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )},
        if (!is.null(self$`stacktrace`)) {
        sprintf(
        '"stacktrace":
          "%s"
                ',
        self$`stacktrace`
        )},
        if (!is.null(self$`status`)) {
        sprintf(
        '"status":
          %d
                ',
        self$`status`
        )},
        if (!is.null(self$`title`)) {
        sprintf(
        '"title":
          "%s"
                ',
        self$`title`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(ErrorJson) {
      ErrorObject <- jsonlite::fromJSON(ErrorJson)
      self$`code` <- ErrorObject$`code`
      self$`stacktrace` <- ErrorObject$`stacktrace`
      self$`status` <- ErrorObject$`status`
      self$`title` <- ErrorObject$`title`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title EventsManifest
#' @description EventsManifest Class
#' @format An \code{R6Class} generator object
#' @field events   \link[HCAClient:EventsManifest_events]{   list(EventsManifestEvents)   }  
#'
#' @field from_date   character  
#'
#' @field journal_id   character  
#'
#' @field size   integer  
#'
#' @field to_date   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
EventsManifest <- R6::R6Class(
  'EventsManifest',
  public = list(
    `events` = NULL,
    `from_date` = NULL,
    `journal_id` = NULL,
    `size` = NULL,
    `to_date` = NULL,
    initialize = function(`events`, `from_date`, `journal_id`, `size`, `to_date`, ...){
      local.optional.var <- list(...)
      if (!missing(`events`)) {
        stopifnot(is.vector(`events`), length(`events`) != 0)
        sapply(`events`, function(x) stopifnot(R6::is.R6(x)))
        self$`events` <- `events`
      }
      if (!missing(`from_date`)) {
        stopifnot(is.character(`from_date`), length(`from_date`) == 1)
        self$`from_date` <- `from_date`
      }
      if (!missing(`journal_id`)) {
        stopifnot(is.character(`journal_id`), length(`journal_id`) == 1)
        self$`journal_id` <- `journal_id`
      }
      if (!missing(`size`)) {
        stopifnot(is.numeric(`size`), length(`size`) == 1)
        self$`size` <- `size`
      }
      if (!missing(`to_date`)) {
        stopifnot(is.character(`to_date`), length(`to_date`) == 1)
        self$`to_date` <- `to_date`
      }
    },
    toJSON = function() {
      EventsManifestObject <- list()
      if (!is.null(self$`events`)) {
        EventsManifestObject[['events']] <-
          lapply(self$`events`, function(x) x$toJSON())
      }
      if (!is.null(self$`from_date`)) {
        EventsManifestObject[['from_date']] <-
          self$`from_date`
      }
      if (!is.null(self$`journal_id`)) {
        EventsManifestObject[['journal_id']] <-
          self$`journal_id`
      }
      if (!is.null(self$`size`)) {
        EventsManifestObject[['size']] <-
          self$`size`
      }
      if (!is.null(self$`to_date`)) {
        EventsManifestObject[['to_date']] <-
          self$`to_date`
      }

      EventsManifestObject
    },
    fromJSON = function(EventsManifestJson) {
      EventsManifestObject <- jsonlite::fromJSON(EventsManifestJson)
      if (!is.null(EventsManifestObject$`events`)) {
        self$`events` <- ApiClient$new()$deserializeObj(EventsManifestObject$`events`, "array[EventsManifestEvents]", "package:HCAClient")
      }
      if (!is.null(EventsManifestObject$`from_date`)) {
        self$`from_date` <- EventsManifestObject$`from_date`
      }
      if (!is.null(EventsManifestObject$`journal_id`)) {
        self$`journal_id` <- EventsManifestObject$`journal_id`
      }
      if (!is.null(EventsManifestObject$`size`)) {
        self$`size` <- EventsManifestObject$`size`
      }
      if (!is.null(EventsManifestObject$`to_date`)) {
        self$`to_date` <- EventsManifestObject$`to_date`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`events`)) {
        sprintf(
        '"events":
        [%s]
',
        paste(sapply(self$`events`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )},
        if (!is.null(self$`from_date`)) {
        sprintf(
        '"from_date":
          "%s"
                ',
        self$`from_date`
        )},
        if (!is.null(self$`journal_id`)) {
        sprintf(
        '"journal_id":
          "%s"
                ',
        self$`journal_id`
        )},
        if (!is.null(self$`size`)) {
        sprintf(
        '"size":
          %d
                ',
        self$`size`
        )},
        if (!is.null(self$`to_date`)) {
        sprintf(
        '"to_date":
          "%s"
                ',
        self$`to_date`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(EventsManifestJson) {
      EventsManifestObject <- jsonlite::fromJSON(EventsManifestJson)
      self$`events` <- ApiClient$new()$deserializeObj(EventsManifestObject$`events`, "array[EventsManifestEvents]","package:HCAClient")
      self$`from_date` <- EventsManifestObject$`from_date`
      self$`journal_id` <- EventsManifestObject$`journal_id`
      self$`size` <- EventsManifestObject$`size`
      self$`to_date` <- EventsManifestObject$`to_date`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title EventsManifestEvents
#' @description EventsManifestEvents Class
#' @format An \code{R6Class} generator object
#' @field event_id   character  
#'
#' @field offset   integer  
#'
#' @field size   integer  
#'
#' @field timestamp   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
EventsManifestEvents <- R6::R6Class(
  'EventsManifestEvents',
  public = list(
    `event_id` = NULL,
    `offset` = NULL,
    `size` = NULL,
    `timestamp` = NULL,
    initialize = function(`event_id`, `offset`, `size`, `timestamp`, ...){
      local.optional.var <- list(...)
      if (!missing(`event_id`)) {
        stopifnot(is.character(`event_id`), length(`event_id`) == 1)
        self$`event_id` <- `event_id`
      }
      if (!missing(`offset`)) {
        stopifnot(is.numeric(`offset`), length(`offset`) == 1)
        self$`offset` <- `offset`
      }
      if (!missing(`size`)) {
        stopifnot(is.numeric(`size`), length(`size`) == 1)
        self$`size` <- `size`
      }
      if (!missing(`timestamp`)) {
        stopifnot(is.character(`timestamp`), length(`timestamp`) == 1)
        self$`timestamp` <- `timestamp`
      }
    },
    toJSON = function() {
      EventsManifestEventsObject <- list()
      if (!is.null(self$`event_id`)) {
        EventsManifestEventsObject[['event_id']] <-
          self$`event_id`
      }
      if (!is.null(self$`offset`)) {
        EventsManifestEventsObject[['offset']] <-
          self$`offset`
      }
      if (!is.null(self$`size`)) {
        EventsManifestEventsObject[['size']] <-
          self$`size`
      }
      if (!is.null(self$`timestamp`)) {
        EventsManifestEventsObject[['timestamp']] <-
          self$`timestamp`
      }

      EventsManifestEventsObject
    },
    fromJSON = function(EventsManifestEventsJson) {
      EventsManifestEventsObject <- jsonlite::fromJSON(EventsManifestEventsJson)
      if (!is.null(EventsManifestEventsObject$`event_id`)) {
        self$`event_id` <- EventsManifestEventsObject$`event_id`
      }
      if (!is.null(EventsManifestEventsObject$`offset`)) {
        self$`offset` <- EventsManifestEventsObject$`offset`
      }
      if (!is.null(EventsManifestEventsObject$`size`)) {
        self$`size` <- EventsManifestEventsObject$`size`
      }
      if (!is.null(EventsManifestEventsObject$`timestamp`)) {
        self$`timestamp` <- EventsManifestEventsObject$`timestamp`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`event_id`)) {
        sprintf(
        '"event_id":
          "%s"
                ',
        self$`event_id`
        )},
        if (!is.null(self$`offset`)) {
        sprintf(
        '"offset":
          %d
                ',
        self$`offset`
        )},
        if (!is.null(self$`size`)) {
        sprintf(
        '"size":
          %d
                ',
        self$`size`
        )},
        if (!is.null(self$`timestamp`)) {
        sprintf(
        '"timestamp":
          "%s"
                ',
        self$`timestamp`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(EventsManifestEventsJson) {
      EventsManifestEventsObject <- jsonlite::fromJSON(EventsManifestEventsJson)
      self$`event_id` <- EventsManifestEventsObject$`event_id`
      self$`offset` <- EventsManifestEventsObject$`offset`
      self$`size` <- EventsManifestEventsObject$`size`
      self$`timestamp` <- EventsManifestEventsObject$`timestamp`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title File
#' @description File Class
#' @format An \code{R6Class} generator object
#' @field name   character  
#'
#' @field uuid   character  
#'
#' @field versions    list(character)   
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
File <- R6::R6Class(
  'File',
  public = list(
    `name` = NULL,
    `uuid` = NULL,
    `versions` = NULL,
    initialize = function(`name`, `uuid`, `versions`, ...){
      local.optional.var <- list(...)
      if (!missing(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`versions`)) {
        stopifnot(is.vector(`versions`), length(`versions`) != 0)
        sapply(`versions`, function(x) stopifnot(is.character(x)))
        self$`versions` <- `versions`
      }
    },
    toJSON = function() {
      FileObject <- list()
      if (!is.null(self$`name`)) {
        FileObject[['name']] <-
          self$`name`
      }
      if (!is.null(self$`uuid`)) {
        FileObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`versions`)) {
        FileObject[['versions']] <-
          self$`versions`
      }

      FileObject
    },
    fromJSON = function(FileJson) {
      FileObject <- jsonlite::fromJSON(FileJson)
      if (!is.null(FileObject$`name`)) {
        self$`name` <- FileObject$`name`
      }
      if (!is.null(FileObject$`uuid`)) {
        self$`uuid` <- FileObject$`uuid`
      }
      if (!is.null(FileObject$`versions`)) {
        self$`versions` <- ApiClient$new()$deserializeObj(FileObject$`versions`, "array[character]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`name`)) {
        sprintf(
        '"name":
          "%s"
                ',
        self$`name`
        )},
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`versions`)) {
        sprintf(
        '"versions":
           [%s]
        ',
        paste(unlist(lapply(self$`versions`, function(x) paste0('"', x, '"'))), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(FileJson) {
      FileObject <- jsonlite::fromJSON(FileJson)
      self$`name` <- FileObject$`name`
      self$`uuid` <- FileObject$`uuid`
      self$`versions` <- ApiClient$new()$deserializeObj(FileObject$`versions`, "array[character]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title FileVersion
#' @description FileVersion Class
#' @format An \code{R6Class} generator object
#' @field content-type   character  
#'
#' @field crc32c   character  
#'
#' @field indexed   character  
#'
#' @field name   character  
#'
#' @field s3_etag   character  
#'
#' @field sha1   character  
#'
#' @field sha256   character  
#'
#' @field size   integer  
#'
#' @field url   character  [optional]
#'
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
FileVersion <- R6::R6Class(
  'FileVersion',
  public = list(
    `content-type` = NULL,
    `crc32c` = NULL,
    `indexed` = NULL,
    `name` = NULL,
    `s3_etag` = NULL,
    `sha1` = NULL,
    `sha256` = NULL,
    `size` = NULL,
    `url` = NULL,
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`content-type`, `crc32c`, `indexed`, `name`, `s3_etag`, `sha1`, `sha256`, `size`, `uuid`, `version`, `url`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`content-type`)) {
        stopifnot(is.character(`content-type`), length(`content-type`) == 1)
        self$`content-type` <- `content-type`
      }
      if (!missing(`crc32c`)) {
        stopifnot(is.character(`crc32c`), length(`crc32c`) == 1)
        self$`crc32c` <- `crc32c`
      }
      if (!missing(`indexed`)) {
        self$`indexed` <- `indexed`
      }
      if (!missing(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!missing(`s3_etag`)) {
        stopifnot(is.character(`s3_etag`), length(`s3_etag`) == 1)
        self$`s3_etag` <- `s3_etag`
      }
      if (!missing(`sha1`)) {
        stopifnot(is.character(`sha1`), length(`sha1`) == 1)
        self$`sha1` <- `sha1`
      }
      if (!missing(`sha256`)) {
        stopifnot(is.character(`sha256`), length(`sha256`) == 1)
        self$`sha256` <- `sha256`
      }
      if (!missing(`size`)) {
        stopifnot(is.numeric(`size`), length(`size`) == 1)
        self$`size` <- `size`
      }
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
      if (!is.null(`url`)) {
        stopifnot(is.character(`url`), length(`url`) == 1)
        self$`url` <- `url`
      }
    },
    toJSON = function() {
      FileVersionObject <- list()
      if (!is.null(self$`content-type`)) {
        FileVersionObject[['content-type']] <-
          self$`content-type`
      }
      if (!is.null(self$`crc32c`)) {
        FileVersionObject[['crc32c']] <-
          self$`crc32c`
      }
      if (!is.null(self$`indexed`)) {
        FileVersionObject[['indexed']] <-
          self$`indexed`
      }
      if (!is.null(self$`name`)) {
        FileVersionObject[['name']] <-
          self$`name`
      }
      if (!is.null(self$`s3_etag`)) {
        FileVersionObject[['s3_etag']] <-
          self$`s3_etag`
      }
      if (!is.null(self$`sha1`)) {
        FileVersionObject[['sha1']] <-
          self$`sha1`
      }
      if (!is.null(self$`sha256`)) {
        FileVersionObject[['sha256']] <-
          self$`sha256`
      }
      if (!is.null(self$`size`)) {
        FileVersionObject[['size']] <-
          self$`size`
      }
      if (!is.null(self$`url`)) {
        FileVersionObject[['url']] <-
          self$`url`
      }
      if (!is.null(self$`uuid`)) {
        FileVersionObject[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        FileVersionObject[['version']] <-
          self$`version`
      }

      FileVersionObject
    },
    fromJSON = function(FileVersionJson) {
      FileVersionObject <- jsonlite::fromJSON(FileVersionJson)
      if (!is.null(FileVersionObject$`content-type`)) {
        self$`content-type` <- FileVersionObject$`content-type`
      }
      if (!is.null(FileVersionObject$`crc32c`)) {
        self$`crc32c` <- FileVersionObject$`crc32c`
      }
      if (!is.null(FileVersionObject$`indexed`)) {
        self$`indexed` <- FileVersionObject$`indexed`
      }
      if (!is.null(FileVersionObject$`name`)) {
        self$`name` <- FileVersionObject$`name`
      }
      if (!is.null(FileVersionObject$`s3_etag`)) {
        self$`s3_etag` <- FileVersionObject$`s3_etag`
      }
      if (!is.null(FileVersionObject$`sha1`)) {
        self$`sha1` <- FileVersionObject$`sha1`
      }
      if (!is.null(FileVersionObject$`sha256`)) {
        self$`sha256` <- FileVersionObject$`sha256`
      }
      if (!is.null(FileVersionObject$`size`)) {
        self$`size` <- FileVersionObject$`size`
      }
      if (!is.null(FileVersionObject$`url`)) {
        self$`url` <- FileVersionObject$`url`
      }
      if (!is.null(FileVersionObject$`uuid`)) {
        self$`uuid` <- FileVersionObject$`uuid`
      }
      if (!is.null(FileVersionObject$`version`)) {
        self$`version` <- FileVersionObject$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`content-type`)) {
        sprintf(
        '"content-type":
          "%s"
                ',
        self$`content-type`
        )},
        if (!is.null(self$`crc32c`)) {
        sprintf(
        '"crc32c":
          "%s"
                ',
        self$`crc32c`
        )},
        if (!is.null(self$`indexed`)) {
        sprintf(
        '"indexed":
          "%s"
                ',
        self$`indexed`
        )},
        if (!is.null(self$`name`)) {
        sprintf(
        '"name":
          "%s"
                ',
        self$`name`
        )},
        if (!is.null(self$`s3_etag`)) {
        sprintf(
        '"s3_etag":
          "%s"
                ',
        self$`s3_etag`
        )},
        if (!is.null(self$`sha1`)) {
        sprintf(
        '"sha1":
          "%s"
                ',
        self$`sha1`
        )},
        if (!is.null(self$`sha256`)) {
        sprintf(
        '"sha256":
          "%s"
                ',
        self$`sha256`
        )},
        if (!is.null(self$`size`)) {
        sprintf(
        '"size":
          %d
                ',
        self$`size`
        )},
        if (!is.null(self$`url`)) {
        sprintf(
        '"url":
          "%s"
                ',
        self$`url`
        )},
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(FileVersionJson) {
      FileVersionObject <- jsonlite::fromJSON(FileVersionJson)
      self$`content-type` <- FileVersionObject$`content-type`
      self$`crc32c` <- FileVersionObject$`crc32c`
      self$`indexed` <- FileVersionObject$`indexed`
      self$`name` <- FileVersionObject$`name`
      self$`s3_etag` <- FileVersionObject$`s3_etag`
      self$`sha1` <- FileVersionObject$`sha1`
      self$`sha256` <- FileVersionObject$`sha256`
      self$`size` <- FileVersionObject$`size`
      self$`url` <- FileVersionObject$`url`
      self$`uuid` <- FileVersionObject$`uuid`
      self$`version` <- FileVersionObject$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title FilesGetResponse
#' @description FilesGetResponse Class
#' @format An \code{R6Class} generator object
#' @field files   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
FilesGetResponse <- R6::R6Class(
  'FilesGetResponse',
  public = list(
    `files` = NULL,
    initialize = function(`files`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`files`)) {
        stopifnot(is.character(`files`), length(`files`) == 1)
        self$`files` <- `files`
      }
    },
    toJSON = function() {
      FilesGetResponseObject <- list()
      if (!is.null(self$`files`)) {
        FilesGetResponseObject[['files']] <-
          self$`files`
      }

      FilesGetResponseObject
    },
    fromJSON = function(FilesGetResponseJson) {
      FilesGetResponseObject <- jsonlite::fromJSON(FilesGetResponseJson)
      if (!is.null(FilesGetResponseObject$`files`)) {
        self$`files` <- FilesGetResponseObject$`files`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`files`)) {
        sprintf(
        '"files":
          "%s"
                ',
        self$`files`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(FilesGetResponseJson) {
      FilesGetResponseObject <- jsonlite::fromJSON(FilesGetResponseJson)
      self$`files` <- FilesGetResponseObject$`files`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject
#' @description InlineObject Class
#' @format An \code{R6Class} generator object
#' @field creator_uid   integer  
#'
#' @field files   \link[HCAClient:BundleFile]{   list(BundleFile)   }  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject <- R6::R6Class(
  'InlineObject',
  public = list(
    `creator_uid` = NULL,
    `files` = NULL,
    initialize = function(`creator_uid`, `files`, ...){
      local.optional.var <- list(...)
      if (!missing(`creator_uid`)) {
        stopifnot(is.numeric(`creator_uid`), length(`creator_uid`) == 1)
        self$`creator_uid` <- `creator_uid`
      }
      if (!missing(`files`)) {
        stopifnot(is.vector(`files`), length(`files`) != 0)
        sapply(`files`, function(x) stopifnot(R6::is.R6(x)))
        self$`files` <- `files`
      }
    },
    toJSON = function() {
      InlineObjectObject <- list()
      if (!is.null(self$`creator_uid`)) {
        InlineObjectObject[['creator_uid']] <-
          self$`creator_uid`
      }
      if (!is.null(self$`files`)) {
        InlineObjectObject[['files']] <-
          lapply(self$`files`, function(x) x$toJSON())
      }

      InlineObjectObject
    },
    fromJSON = function(InlineObjectJson) {
      InlineObjectObject <- jsonlite::fromJSON(InlineObjectJson)
      if (!is.null(InlineObjectObject$`creator_uid`)) {
        self$`creator_uid` <- InlineObjectObject$`creator_uid`
      }
      if (!is.null(InlineObjectObject$`files`)) {
        self$`files` <- ApiClient$new()$deserializeObj(InlineObjectObject$`files`, "array[BundleFile]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`creator_uid`)) {
        sprintf(
        '"creator_uid":
          %d
                ',
        self$`creator_uid`
        )},
        if (!is.null(self$`files`)) {
        sprintf(
        '"files":
        [%s]
',
        paste(sapply(self$`files`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObjectJson) {
      InlineObjectObject <- jsonlite::fromJSON(InlineObjectJson)
      self$`creator_uid` <- InlineObjectObject$`creator_uid`
      self$`files` <- ApiClient$new()$deserializeObj(InlineObjectObject$`files`, "array[BundleFile]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject1
#' @description InlineObject1 Class
#' @format An \code{R6Class} generator object
#' @field reason   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject1 <- R6::R6Class(
  'InlineObject1',
  public = list(
    `reason` = NULL,
    initialize = function(`reason`, ...){
      local.optional.var <- list(...)
      if (!missing(`reason`)) {
        stopifnot(is.character(`reason`), length(`reason`) == 1)
        self$`reason` <- `reason`
      }
    },
    toJSON = function() {
      InlineObject1Object <- list()
      if (!is.null(self$`reason`)) {
        InlineObject1Object[['reason']] <-
          self$`reason`
      }

      InlineObject1Object
    },
    fromJSON = function(InlineObject1Json) {
      InlineObject1Object <- jsonlite::fromJSON(InlineObject1Json)
      if (!is.null(InlineObject1Object$`reason`)) {
        self$`reason` <- InlineObject1Object$`reason`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`reason`)) {
        sprintf(
        '"reason":
          "%s"
                ',
        self$`reason`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject1Json) {
      InlineObject1Object <- jsonlite::fromJSON(InlineObject1Json)
      self$`reason` <- InlineObject1Object$`reason`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject2
#' @description InlineObject2 Class
#' @format An \code{R6Class} generator object
#' @field add_files   \link[HCAClient:BundleFile]{   list(BundleFile)   }  [optional]
#'
#' @field remove_files   \link[HCAClient:BundleFile]{   list(BundleFile)   }  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject2 <- R6::R6Class(
  'InlineObject2',
  public = list(
    `add_files` = NULL,
    `remove_files` = NULL,
    initialize = function(`add_files`=NULL, `remove_files`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`add_files`)) {
        stopifnot(is.vector(`add_files`), length(`add_files`) != 0)
        sapply(`add_files`, function(x) stopifnot(R6::is.R6(x)))
        self$`add_files` <- `add_files`
      }
      if (!is.null(`remove_files`)) {
        stopifnot(is.vector(`remove_files`), length(`remove_files`) != 0)
        sapply(`remove_files`, function(x) stopifnot(R6::is.R6(x)))
        self$`remove_files` <- `remove_files`
      }
    },
    toJSON = function() {
      InlineObject2Object <- list()
      if (!is.null(self$`add_files`)) {
        InlineObject2Object[['add_files']] <-
          lapply(self$`add_files`, function(x) x$toJSON())
      }
      if (!is.null(self$`remove_files`)) {
        InlineObject2Object[['remove_files']] <-
          lapply(self$`remove_files`, function(x) x$toJSON())
      }

      InlineObject2Object
    },
    fromJSON = function(InlineObject2Json) {
      InlineObject2Object <- jsonlite::fromJSON(InlineObject2Json)
      if (!is.null(InlineObject2Object$`add_files`)) {
        self$`add_files` <- ApiClient$new()$deserializeObj(InlineObject2Object$`add_files`, "array[BundleFile]", "package:HCAClient")
      }
      if (!is.null(InlineObject2Object$`remove_files`)) {
        self$`remove_files` <- ApiClient$new()$deserializeObj(InlineObject2Object$`remove_files`, "array[BundleFile]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`add_files`)) {
        sprintf(
        '"add_files":
        [%s]
',
        paste(sapply(self$`add_files`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )},
        if (!is.null(self$`remove_files`)) {
        sprintf(
        '"remove_files":
        [%s]
',
        paste(sapply(self$`remove_files`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject2Json) {
      InlineObject2Object <- jsonlite::fromJSON(InlineObject2Json)
      self$`add_files` <- ApiClient$new()$deserializeObj(InlineObject2Object$`add_files`, "array[BundleFile]","package:HCAClient")
      self$`remove_files` <- ApiClient$new()$deserializeObj(InlineObject2Object$`remove_files`, "array[BundleFile]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject3
#' @description InlineObject3 Class
#' @format An \code{R6Class} generator object
#' @field destination   character  [optional]
#'
#' @field email   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject3 <- R6::R6Class(
  'InlineObject3',
  public = list(
    `destination` = NULL,
    `email` = NULL,
    initialize = function(`destination`=NULL, `email`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`destination`)) {
        stopifnot(is.character(`destination`), length(`destination`) == 1)
        self$`destination` <- `destination`
      }
      if (!is.null(`email`)) {
        stopifnot(is.character(`email`), length(`email`) == 1)
        self$`email` <- `email`
      }
    },
    toJSON = function() {
      InlineObject3Object <- list()
      if (!is.null(self$`destination`)) {
        InlineObject3Object[['destination']] <-
          self$`destination`
      }
      if (!is.null(self$`email`)) {
        InlineObject3Object[['email']] <-
          self$`email`
      }

      InlineObject3Object
    },
    fromJSON = function(InlineObject3Json) {
      InlineObject3Object <- jsonlite::fromJSON(InlineObject3Json)
      if (!is.null(InlineObject3Object$`destination`)) {
        self$`destination` <- InlineObject3Object$`destination`
      }
      if (!is.null(InlineObject3Object$`email`)) {
        self$`email` <- InlineObject3Object$`email`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`destination`)) {
        sprintf(
        '"destination":
          "%s"
                ',
        self$`destination`
        )},
        if (!is.null(self$`email`)) {
        sprintf(
        '"email":
          "%s"
                ',
        self$`email`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject3Json) {
      InlineObject3Object <- jsonlite::fromJSON(InlineObject3Json)
      self$`destination` <- InlineObject3Object$`destination`
      self$`email` <- InlineObject3Object$`email`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject4
#' @description InlineObject4 Class
#' @format An \code{R6Class} generator object
#' @field add_contents   \link[HCAClient:CollectionItem]{   list(CollectionItem)   }  [optional]
#'
#' @field description   character  [optional]
#'
#' @field details   \link[HCAClient:]{  object  }  [optional]
#'
#' @field name   character  [optional]
#'
#' @field remove_contents   \link[HCAClient:CollectionItem]{   list(CollectionItem)   }  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject4 <- R6::R6Class(
  'InlineObject4',
  public = list(
    `add_contents` = NULL,
    `description` = NULL,
    `details` = NULL,
    `name` = NULL,
    `remove_contents` = NULL,
    initialize = function(`add_contents`=NULL, `description`=NULL, `details`=NULL, `name`=NULL, `remove_contents`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`add_contents`)) {
        stopifnot(is.vector(`add_contents`), length(`add_contents`) != 0)
        sapply(`add_contents`, function(x) stopifnot(R6::is.R6(x)))
        self$`add_contents` <- `add_contents`
      }
      if (!is.null(`description`)) {
        stopifnot(is.character(`description`), length(`description`) == 1)
        self$`description` <- `description`
      }
      if (!is.null(`details`)) {
        stopifnot(R6::is.R6(`details`))
        self$`details` <- `details`
      }
      if (!is.null(`name`)) {
        stopifnot(is.character(`name`), length(`name`) == 1)
        self$`name` <- `name`
      }
      if (!is.null(`remove_contents`)) {
        stopifnot(is.vector(`remove_contents`), length(`remove_contents`) != 0)
        sapply(`remove_contents`, function(x) stopifnot(R6::is.R6(x)))
        self$`remove_contents` <- `remove_contents`
      }
    },
    toJSON = function() {
      InlineObject4Object <- list()
      if (!is.null(self$`add_contents`)) {
        InlineObject4Object[['add_contents']] <-
          lapply(self$`add_contents`, function(x) x$toJSON())
      }
      if (!is.null(self$`description`)) {
        InlineObject4Object[['description']] <-
          self$`description`
      }
      if (!is.null(self$`details`)) {
        InlineObject4Object[['details']] <-
          self$`details`$toJSON()
      }
      if (!is.null(self$`name`)) {
        InlineObject4Object[['name']] <-
          self$`name`
      }
      if (!is.null(self$`remove_contents`)) {
        InlineObject4Object[['remove_contents']] <-
          lapply(self$`remove_contents`, function(x) x$toJSON())
      }

      InlineObject4Object
    },
    fromJSON = function(InlineObject4Json) {
      InlineObject4Object <- jsonlite::fromJSON(InlineObject4Json)
      if (!is.null(InlineObject4Object$`add_contents`)) {
        self$`add_contents` <- ApiClient$new()$deserializeObj(InlineObject4Object$`add_contents`, "array[CollectionItem]", "package:HCAClient")
      }
      if (!is.null(InlineObject4Object$`description`)) {
        self$`description` <- InlineObject4Object$`description`
      }
      if (!is.null(InlineObject4Object$`details`)) {
        detailsObject <- object$new()
        detailsObject$fromJSON(jsonlite::toJSON(InlineObject4Object$details, auto_unbox = TRUE, digits = NA))
        self$`details` <- detailsObject
      }
      if (!is.null(InlineObject4Object$`name`)) {
        self$`name` <- InlineObject4Object$`name`
      }
      if (!is.null(InlineObject4Object$`remove_contents`)) {
        self$`remove_contents` <- ApiClient$new()$deserializeObj(InlineObject4Object$`remove_contents`, "array[CollectionItem]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`add_contents`)) {
        sprintf(
        '"add_contents":
        [%s]
',
        paste(sapply(self$`add_contents`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )},
        if (!is.null(self$`description`)) {
        sprintf(
        '"description":
          "%s"
                ',
        self$`description`
        )},
        if (!is.null(self$`details`)) {
        sprintf(
        '"details":
        %s
        ',
        jsonlite::toJSON(self$`details`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`name`)) {
        sprintf(
        '"name":
          "%s"
                ',
        self$`name`
        )},
        if (!is.null(self$`remove_contents`)) {
        sprintf(
        '"remove_contents":
        [%s]
',
        paste(sapply(self$`remove_contents`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject4Json) {
      InlineObject4Object <- jsonlite::fromJSON(InlineObject4Json)
      self$`add_contents` <- ApiClient$new()$deserializeObj(InlineObject4Object$`add_contents`, "array[CollectionItem]","package:HCAClient")
      self$`description` <- InlineObject4Object$`description`
      self$`details` <- object$new()$fromJSON(jsonlite::toJSON(InlineObject4Object$details, auto_unbox = TRUE, digits = NA))
      self$`name` <- InlineObject4Object$`name`
      self$`remove_contents` <- ApiClient$new()$deserializeObj(InlineObject4Object$`remove_contents`, "array[CollectionItem]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject5
#' @description InlineObject5 Class
#' @format An \code{R6Class} generator object
#' @field creator_uid   integer  
#'
#' @field source_url   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject5 <- R6::R6Class(
  'InlineObject5',
  public = list(
    `creator_uid` = NULL,
    `source_url` = NULL,
    initialize = function(`creator_uid`, `source_url`, ...){
      local.optional.var <- list(...)
      if (!missing(`creator_uid`)) {
        stopifnot(is.numeric(`creator_uid`), length(`creator_uid`) == 1)
        self$`creator_uid` <- `creator_uid`
      }
      if (!missing(`source_url`)) {
        stopifnot(is.character(`source_url`), length(`source_url`) == 1)
        self$`source_url` <- `source_url`
      }
    },
    toJSON = function() {
      InlineObject5Object <- list()
      if (!is.null(self$`creator_uid`)) {
        InlineObject5Object[['creator_uid']] <-
          self$`creator_uid`
      }
      if (!is.null(self$`source_url`)) {
        InlineObject5Object[['source_url']] <-
          self$`source_url`
      }

      InlineObject5Object
    },
    fromJSON = function(InlineObject5Json) {
      InlineObject5Object <- jsonlite::fromJSON(InlineObject5Json)
      if (!is.null(InlineObject5Object$`creator_uid`)) {
        self$`creator_uid` <- InlineObject5Object$`creator_uid`
      }
      if (!is.null(InlineObject5Object$`source_url`)) {
        self$`source_url` <- InlineObject5Object$`source_url`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`creator_uid`)) {
        sprintf(
        '"creator_uid":
          %d
                ',
        self$`creator_uid`
        )},
        if (!is.null(self$`source_url`)) {
        sprintf(
        '"source_url":
          "%s"
                ',
        self$`source_url`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject5Json) {
      InlineObject5Object <- jsonlite::fromJSON(InlineObject5Json)
      self$`creator_uid` <- InlineObject5Object$`creator_uid`
      self$`source_url` <- InlineObject5Object$`source_url`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject6
#' @description InlineObject6 Class
#' @format An \code{R6Class} generator object
#' @field es_query   \link[HCAClient:]{  object  }  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject6 <- R6::R6Class(
  'InlineObject6',
  public = list(
    `es_query` = NULL,
    initialize = function(`es_query`, ...){
      local.optional.var <- list(...)
      if (!missing(`es_query`)) {
        stopifnot(R6::is.R6(`es_query`))
        self$`es_query` <- `es_query`
      }
    },
    toJSON = function() {
      InlineObject6Object <- list()
      if (!is.null(self$`es_query`)) {
        InlineObject6Object[['es_query']] <-
          self$`es_query`$toJSON()
      }

      InlineObject6Object
    },
    fromJSON = function(InlineObject6Json) {
      InlineObject6Object <- jsonlite::fromJSON(InlineObject6Json)
      if (!is.null(InlineObject6Object$`es_query`)) {
        es_queryObject <- object$new()
        es_queryObject$fromJSON(jsonlite::toJSON(InlineObject6Object$es_query, auto_unbox = TRUE, digits = NA))
        self$`es_query` <- es_queryObject
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`es_query`)) {
        sprintf(
        '"es_query":
        %s
        ',
        jsonlite::toJSON(self$`es_query`$toJSON(), auto_unbox=TRUE, digits = NA)
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject6Json) {
      InlineObject6Object <- jsonlite::fromJSON(InlineObject6Json)
      self$`es_query` <- object$new()$fromJSON(jsonlite::toJSON(InlineObject6Object$es_query, auto_unbox = TRUE, digits = NA))
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineObject7
#' @description InlineObject7 Class
#' @format An \code{R6Class} generator object
#' @field attachments   \link[HCAClient:_subscriptions_attachments]{   named list(SubscriptionsAttachments)   }  [optional]
#'
#' @field callback_url   character  
#'
#' @field encoding   character  [optional]
#'
#' @field es_query   \link[HCAClient:]{  object  }  [optional]
#'
#' @field form_fields    named list(character)   [optional]
#'
#' @field hmac_key_id   character  [optional]
#'
#' @field hmac_secret_key   character  [optional]
#'
#' @field jmespath_query   character  [optional]
#'
#' @field method   character  [optional]
#'
#' @field payload_form_field   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineObject7 <- R6::R6Class(
  'InlineObject7',
  public = list(
    `attachments` = NULL,
    `callback_url` = NULL,
    `encoding` = NULL,
    `es_query` = NULL,
    `form_fields` = NULL,
    `hmac_key_id` = NULL,
    `hmac_secret_key` = NULL,
    `jmespath_query` = NULL,
    `method` = NULL,
    `payload_form_field` = NULL,
    initialize = function(`callback_url`, `attachments`=NULL, `encoding`='application/json', `es_query`=NULL, `form_fields`=NULL, `hmac_key_id`=NULL, `hmac_secret_key`=NULL, `jmespath_query`=NULL, `method`='POST', `payload_form_field`='payload', ...){
      local.optional.var <- list(...)
      if (!missing(`callback_url`)) {
        stopifnot(is.character(`callback_url`), length(`callback_url`) == 1)
        self$`callback_url` <- `callback_url`
      }
      if (!is.null(`attachments`)) {
        stopifnot(is.vector(`attachments`), length(`attachments`) != 0)
        sapply(`attachments`, function(x) stopifnot(R6::is.R6(x)))
        self$`attachments` <- `attachments`
      }
      if (!is.null(`encoding`)) {
        stopifnot(is.character(`encoding`), length(`encoding`) == 1)
        self$`encoding` <- `encoding`
      }
      if (!is.null(`es_query`)) {
        stopifnot(R6::is.R6(`es_query`))
        self$`es_query` <- `es_query`
      }
      if (!is.null(`form_fields`)) {
        stopifnot(is.vector(`form_fields`), length(`form_fields`) != 0)
        sapply(`form_fields`, function(x) stopifnot(is.character(x)))
        self$`form_fields` <- `form_fields`
      }
      if (!is.null(`hmac_key_id`)) {
        stopifnot(is.character(`hmac_key_id`), length(`hmac_key_id`) == 1)
        self$`hmac_key_id` <- `hmac_key_id`
      }
      if (!is.null(`hmac_secret_key`)) {
        stopifnot(is.character(`hmac_secret_key`), length(`hmac_secret_key`) == 1)
        self$`hmac_secret_key` <- `hmac_secret_key`
      }
      if (!is.null(`jmespath_query`)) {
        stopifnot(is.character(`jmespath_query`), length(`jmespath_query`) == 1)
        self$`jmespath_query` <- `jmespath_query`
      }
      if (!is.null(`method`)) {
        stopifnot(is.character(`method`), length(`method`) == 1)
        self$`method` <- `method`
      }
      if (!is.null(`payload_form_field`)) {
        stopifnot(is.character(`payload_form_field`), length(`payload_form_field`) == 1)
        self$`payload_form_field` <- `payload_form_field`
      }
    },
    toJSON = function() {
      InlineObject7Object <- list()
      if (!is.null(self$`attachments`)) {
        InlineObject7Object[['attachments']] <-
          lapply(self$`attachments`, function(x) x$toJSON())
      }
      if (!is.null(self$`callback_url`)) {
        InlineObject7Object[['callback_url']] <-
          self$`callback_url`
      }
      if (!is.null(self$`encoding`)) {
        InlineObject7Object[['encoding']] <-
          self$`encoding`
      }
      if (!is.null(self$`es_query`)) {
        InlineObject7Object[['es_query']] <-
          self$`es_query`$toJSON()
      }
      if (!is.null(self$`form_fields`)) {
        InlineObject7Object[['form_fields']] <-
          self$`form_fields`
      }
      if (!is.null(self$`hmac_key_id`)) {
        InlineObject7Object[['hmac_key_id']] <-
          self$`hmac_key_id`
      }
      if (!is.null(self$`hmac_secret_key`)) {
        InlineObject7Object[['hmac_secret_key']] <-
          self$`hmac_secret_key`
      }
      if (!is.null(self$`jmespath_query`)) {
        InlineObject7Object[['jmespath_query']] <-
          self$`jmespath_query`
      }
      if (!is.null(self$`method`)) {
        InlineObject7Object[['method']] <-
          self$`method`
      }
      if (!is.null(self$`payload_form_field`)) {
        InlineObject7Object[['payload_form_field']] <-
          self$`payload_form_field`
      }

      InlineObject7Object
    },
    fromJSON = function(InlineObject7Json) {
      InlineObject7Object <- jsonlite::fromJSON(InlineObject7Json)
      if (!is.null(InlineObject7Object$`attachments`)) {
        self$`attachments` <- ApiClient$new()$deserializeObj(InlineObject7Object$`attachments`, "map(SubscriptionsAttachments)", "package:HCAClient")
      }
      if (!is.null(InlineObject7Object$`callback_url`)) {
        self$`callback_url` <- InlineObject7Object$`callback_url`
      }
      if (!is.null(InlineObject7Object$`encoding`)) {
        self$`encoding` <- InlineObject7Object$`encoding`
      }
      if (!is.null(InlineObject7Object$`es_query`)) {
        es_queryObject <- object$new()
        es_queryObject$fromJSON(jsonlite::toJSON(InlineObject7Object$es_query, auto_unbox = TRUE, digits = NA))
        self$`es_query` <- es_queryObject
      }
      if (!is.null(InlineObject7Object$`form_fields`)) {
        self$`form_fields` <- ApiClient$new()$deserializeObj(InlineObject7Object$`form_fields`, "map(character)", "package:HCAClient")
      }
      if (!is.null(InlineObject7Object$`hmac_key_id`)) {
        self$`hmac_key_id` <- InlineObject7Object$`hmac_key_id`
      }
      if (!is.null(InlineObject7Object$`hmac_secret_key`)) {
        self$`hmac_secret_key` <- InlineObject7Object$`hmac_secret_key`
      }
      if (!is.null(InlineObject7Object$`jmespath_query`)) {
        self$`jmespath_query` <- InlineObject7Object$`jmespath_query`
      }
      if (!is.null(InlineObject7Object$`method`)) {
        self$`method` <- InlineObject7Object$`method`
      }
      if (!is.null(InlineObject7Object$`payload_form_field`)) {
        self$`payload_form_field` <- InlineObject7Object$`payload_form_field`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`attachments`)) {
        sprintf(
        '"attachments":
        %s
',
        jsonlite::toJSON(lapply(self$`attachments`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits=NA)
        )},
        if (!is.null(self$`callback_url`)) {
        sprintf(
        '"callback_url":
          "%s"
                ',
        self$`callback_url`
        )},
        if (!is.null(self$`encoding`)) {
        sprintf(
        '"encoding":
          "%s"
                ',
        self$`encoding`
        )},
        if (!is.null(self$`es_query`)) {
        sprintf(
        '"es_query":
        %s
        ',
        jsonlite::toJSON(self$`es_query`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`form_fields`)) {
        sprintf(
        '"form_fields":
          "%s"
        ',
        jsonlite::toJSON(lapply(self$`form_fields`, function(x){ x }), auto_unbox = TRUE, digits=NA)
        )},
        if (!is.null(self$`hmac_key_id`)) {
        sprintf(
        '"hmac_key_id":
          "%s"
                ',
        self$`hmac_key_id`
        )},
        if (!is.null(self$`hmac_secret_key`)) {
        sprintf(
        '"hmac_secret_key":
          "%s"
                ',
        self$`hmac_secret_key`
        )},
        if (!is.null(self$`jmespath_query`)) {
        sprintf(
        '"jmespath_query":
          "%s"
                ',
        self$`jmespath_query`
        )},
        if (!is.null(self$`method`)) {
        sprintf(
        '"method":
          "%s"
                ',
        self$`method`
        )},
        if (!is.null(self$`payload_form_field`)) {
        sprintf(
        '"payload_form_field":
          "%s"
                ',
        self$`payload_form_field`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineObject7Json) {
      InlineObject7Object <- jsonlite::fromJSON(InlineObject7Json)
      self$`attachments` <- ApiClient$new()$deserializeObj(InlineObject7Object$`attachments`, "map(SubscriptionsAttachments)","package:HCAClient")
      self$`callback_url` <- InlineObject7Object$`callback_url`
      self$`encoding` <- InlineObject7Object$`encoding`
      self$`es_query` <- object$new()$fromJSON(jsonlite::toJSON(InlineObject7Object$es_query, auto_unbox = TRUE, digits = NA))
      self$`form_fields` <- ApiClient$new()$deserializeObj(InlineObject7Object$`form_fields`, "map(character)","package:HCAClient")
      self$`hmac_key_id` <- InlineObject7Object$`hmac_key_id`
      self$`hmac_secret_key` <- InlineObject7Object$`hmac_secret_key`
      self$`jmespath_query` <- InlineObject7Object$`jmespath_query`
      self$`method` <- InlineObject7Object$`method`
      self$`payload_form_field` <- InlineObject7Object$`payload_form_field`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse200
#' @description InlineResponse200 Class
#' @format An \code{R6Class} generator object
#' @field cause   character  [optional]
#'
#' @field status   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse200 <- R6::R6Class(
  'InlineResponse200',
  public = list(
    `cause` = NULL,
    `status` = NULL,
    initialize = function(`status`, `cause`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`status`)) {
        stopifnot(is.character(`status`), length(`status`) == 1)
        self$`status` <- `status`
      }
      if (!is.null(`cause`)) {
        stopifnot(is.character(`cause`), length(`cause`) == 1)
        self$`cause` <- `cause`
      }
    },
    toJSON = function() {
      InlineResponse200Object <- list()
      if (!is.null(self$`cause`)) {
        InlineResponse200Object[['cause']] <-
          self$`cause`
      }
      if (!is.null(self$`status`)) {
        InlineResponse200Object[['status']] <-
          self$`status`
      }

      InlineResponse200Object
    },
    fromJSON = function(InlineResponse200Json) {
      InlineResponse200Object <- jsonlite::fromJSON(InlineResponse200Json)
      if (!is.null(InlineResponse200Object$`cause`)) {
        self$`cause` <- InlineResponse200Object$`cause`
      }
      if (!is.null(InlineResponse200Object$`status`)) {
        self$`status` <- InlineResponse200Object$`status`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`cause`)) {
        sprintf(
        '"cause":
          "%s"
                ',
        self$`cause`
        )},
        if (!is.null(self$`status`)) {
        sprintf(
        '"status":
          "%s"
                ',
        self$`status`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse200Json) {
      InlineResponse200Object <- jsonlite::fromJSON(InlineResponse200Json)
      self$`cause` <- InlineResponse200Object$`cause`
      self$`status` <- InlineResponse200Object$`status`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2001
#' @description InlineResponse2001 Class
#' @format An \code{R6Class} generator object
#' @field bundle   \link[HCAClient:bundle_version]{  BundleVersion  }  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2001 <- R6::R6Class(
  'InlineResponse2001',
  public = list(
    `bundle` = NULL,
    initialize = function(`bundle`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`bundle`)) {
        stopifnot(R6::is.R6(`bundle`))
        self$`bundle` <- `bundle`
      }
    },
    toJSON = function() {
      InlineResponse2001Object <- list()
      if (!is.null(self$`bundle`)) {
        InlineResponse2001Object[['bundle']] <-
          self$`bundle`$toJSON()
      }

      InlineResponse2001Object
    },
    fromJSON = function(InlineResponse2001Json) {
      InlineResponse2001Object <- jsonlite::fromJSON(InlineResponse2001Json)
      if (!is.null(InlineResponse2001Object$`bundle`)) {
        bundleObject <- BundleVersion$new()
        bundleObject$fromJSON(jsonlite::toJSON(InlineResponse2001Object$bundle, auto_unbox = TRUE, digits = NA))
        self$`bundle` <- bundleObject
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`bundle`)) {
        sprintf(
        '"bundle":
        %s
        ',
        jsonlite::toJSON(self$`bundle`$toJSON(), auto_unbox=TRUE, digits = NA)
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2001Json) {
      InlineResponse2001Object <- jsonlite::fromJSON(InlineResponse2001Json)
      self$`bundle` <- BundleVersion$new()$fromJSON(jsonlite::toJSON(InlineResponse2001Object$bundle, auto_unbox = TRUE, digits = NA))
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse20010
#' @description InlineResponse20010 Class
#' @format An \code{R6Class} generator object
#' @field subscriptions   \link[HCAClient:Subscription]{   list(Subscription)   }  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse20010 <- R6::R6Class(
  'InlineResponse20010',
  public = list(
    `subscriptions` = NULL,
    initialize = function(`subscriptions`, ...){
      local.optional.var <- list(...)
      if (!missing(`subscriptions`)) {
        stopifnot(is.vector(`subscriptions`), length(`subscriptions`) != 0)
        sapply(`subscriptions`, function(x) stopifnot(R6::is.R6(x)))
        self$`subscriptions` <- `subscriptions`
      }
    },
    toJSON = function() {
      InlineResponse20010Object <- list()
      if (!is.null(self$`subscriptions`)) {
        InlineResponse20010Object[['subscriptions']] <-
          lapply(self$`subscriptions`, function(x) x$toJSON())
      }

      InlineResponse20010Object
    },
    fromJSON = function(InlineResponse20010Json) {
      InlineResponse20010Object <- jsonlite::fromJSON(InlineResponse20010Json)
      if (!is.null(InlineResponse20010Object$`subscriptions`)) {
        self$`subscriptions` <- ApiClient$new()$deserializeObj(InlineResponse20010Object$`subscriptions`, "array[Subscription]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`subscriptions`)) {
        sprintf(
        '"subscriptions":
        [%s]
',
        paste(sapply(self$`subscriptions`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse20010Json) {
      InlineResponse20010Object <- jsonlite::fromJSON(InlineResponse20010Json)
      self$`subscriptions` <- ApiClient$new()$deserializeObj(InlineResponse20010Object$`subscriptions`, "array[Subscription]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse20011
#' @description InlineResponse20011 Class
#' @format An \code{R6Class} generator object
#' @field subscription   \link[HCAClient:Subscription]{  Subscription  }  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse20011 <- R6::R6Class(
  'InlineResponse20011',
  public = list(
    `subscription` = NULL,
    initialize = function(`subscription`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`subscription`)) {
        stopifnot(R6::is.R6(`subscription`))
        self$`subscription` <- `subscription`
      }
    },
    toJSON = function() {
      InlineResponse20011Object <- list()
      if (!is.null(self$`subscription`)) {
        InlineResponse20011Object[['subscription']] <-
          self$`subscription`$toJSON()
      }

      InlineResponse20011Object
    },
    fromJSON = function(InlineResponse20011Json) {
      InlineResponse20011Object <- jsonlite::fromJSON(InlineResponse20011Json)
      if (!is.null(InlineResponse20011Object$`subscription`)) {
        subscriptionObject <- Subscription$new()
        subscriptionObject$fromJSON(jsonlite::toJSON(InlineResponse20011Object$subscription, auto_unbox = TRUE, digits = NA))
        self$`subscription` <- subscriptionObject
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`subscription`)) {
        sprintf(
        '"subscription":
        %s
        ',
        jsonlite::toJSON(self$`subscription`$toJSON(), auto_unbox=TRUE, digits = NA)
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse20011Json) {
      InlineResponse20011Object <- jsonlite::fromJSON(InlineResponse20011Json)
      self$`subscription` <- Subscription$new()$fromJSON(jsonlite::toJSON(InlineResponse20011Object$subscription, auto_unbox = TRUE, digits = NA))
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse20012
#' @description InlineResponse20012 Class
#' @format An \code{R6Class} generator object
#' @field timeDeleted   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse20012 <- R6::R6Class(
  'InlineResponse20012',
  public = list(
    `timeDeleted` = NULL,
    initialize = function(`timeDeleted`, ...){
      local.optional.var <- list(...)
      if (!missing(`timeDeleted`)) {
        stopifnot(is.character(`timeDeleted`), length(`timeDeleted`) == 1)
        self$`timeDeleted` <- `timeDeleted`
      }
    },
    toJSON = function() {
      InlineResponse20012Object <- list()
      if (!is.null(self$`timeDeleted`)) {
        InlineResponse20012Object[['timeDeleted']] <-
          self$`timeDeleted`
      }

      InlineResponse20012Object
    },
    fromJSON = function(InlineResponse20012Json) {
      InlineResponse20012Object <- jsonlite::fromJSON(InlineResponse20012Json)
      if (!is.null(InlineResponse20012Object$`timeDeleted`)) {
        self$`timeDeleted` <- InlineResponse20012Object$`timeDeleted`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`timeDeleted`)) {
        sprintf(
        '"timeDeleted":
          "%s"
                ',
        self$`timeDeleted`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse20012Json) {
      InlineResponse20012Object <- jsonlite::fromJSON(InlineResponse20012Json)
      self$`timeDeleted` <- InlineResponse20012Object$`timeDeleted`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2002
#' @description InlineResponse2002 Class
#' @format An \code{R6Class} generator object
#' @field manifest   \link[HCAClient:]{  object  }  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2002 <- R6::R6Class(
  'InlineResponse2002',
  public = list(
    `manifest` = NULL,
    `version` = NULL,
    initialize = function(`manifest`, `version`, ...){
      local.optional.var <- list(...)
      if (!missing(`manifest`)) {
        stopifnot(R6::is.R6(`manifest`))
        self$`manifest` <- `manifest`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      InlineResponse2002Object <- list()
      if (!is.null(self$`manifest`)) {
        InlineResponse2002Object[['manifest']] <-
          self$`manifest`$toJSON()
      }
      if (!is.null(self$`version`)) {
        InlineResponse2002Object[['version']] <-
          self$`version`
      }

      InlineResponse2002Object
    },
    fromJSON = function(InlineResponse2002Json) {
      InlineResponse2002Object <- jsonlite::fromJSON(InlineResponse2002Json)
      if (!is.null(InlineResponse2002Object$`manifest`)) {
        manifestObject <- object$new()
        manifestObject$fromJSON(jsonlite::toJSON(InlineResponse2002Object$manifest, auto_unbox = TRUE, digits = NA))
        self$`manifest` <- manifestObject
      }
      if (!is.null(InlineResponse2002Object$`version`)) {
        self$`version` <- InlineResponse2002Object$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`manifest`)) {
        sprintf(
        '"manifest":
        %s
        ',
        jsonlite::toJSON(self$`manifest`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2002Json) {
      InlineResponse2002Object <- jsonlite::fromJSON(InlineResponse2002Json)
      self$`manifest` <- object$new()$fromJSON(jsonlite::toJSON(InlineResponse2002Object$manifest, auto_unbox = TRUE, digits = NA))
      self$`version` <- InlineResponse2002Object$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2003
#' @description InlineResponse2003 Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2003 <- R6::R6Class(
  'InlineResponse2003',
  public = list(
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`uuid`, `version`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      InlineResponse2003Object <- list()
      if (!is.null(self$`uuid`)) {
        InlineResponse2003Object[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        InlineResponse2003Object[['version']] <-
          self$`version`
      }

      InlineResponse2003Object
    },
    fromJSON = function(InlineResponse2003Json) {
      InlineResponse2003Object <- jsonlite::fromJSON(InlineResponse2003Json)
      if (!is.null(InlineResponse2003Object$`uuid`)) {
        self$`uuid` <- InlineResponse2003Object$`uuid`
      }
      if (!is.null(InlineResponse2003Object$`version`)) {
        self$`version` <- InlineResponse2003Object$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2003Json) {
      InlineResponse2003Object <- jsonlite::fromJSON(InlineResponse2003Json)
      self$`uuid` <- InlineResponse2003Object$`uuid`
      self$`version` <- InlineResponse2003Object$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2004
#' @description InlineResponse2004 Class
#' @format An \code{R6Class} generator object
#' @field checkout_job_id   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2004 <- R6::R6Class(
  'InlineResponse2004',
  public = list(
    `checkout_job_id` = NULL,
    initialize = function(`checkout_job_id`, ...){
      local.optional.var <- list(...)
      if (!missing(`checkout_job_id`)) {
        stopifnot(is.character(`checkout_job_id`), length(`checkout_job_id`) == 1)
        self$`checkout_job_id` <- `checkout_job_id`
      }
    },
    toJSON = function() {
      InlineResponse2004Object <- list()
      if (!is.null(self$`checkout_job_id`)) {
        InlineResponse2004Object[['checkout_job_id']] <-
          self$`checkout_job_id`
      }

      InlineResponse2004Object
    },
    fromJSON = function(InlineResponse2004Json) {
      InlineResponse2004Object <- jsonlite::fromJSON(InlineResponse2004Json)
      if (!is.null(InlineResponse2004Object$`checkout_job_id`)) {
        self$`checkout_job_id` <- InlineResponse2004Object$`checkout_job_id`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`checkout_job_id`)) {
        sprintf(
        '"checkout_job_id":
          "%s"
                ',
        self$`checkout_job_id`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2004Json) {
      InlineResponse2004Object <- jsonlite::fromJSON(InlineResponse2004Json)
      self$`checkout_job_id` <- InlineResponse2004Object$`checkout_job_id`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2005
#' @description InlineResponse2005 Class
#' @format An \code{R6Class} generator object
#' @field collections   \link[HCAClient:CollectionOfCollectionsItem]{   list(CollectionOfCollectionsItem)   }  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2005 <- R6::R6Class(
  'InlineResponse2005',
  public = list(
    `collections` = NULL,
    initialize = function(`collections`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`collections`)) {
        stopifnot(is.vector(`collections`), length(`collections`) != 0)
        sapply(`collections`, function(x) stopifnot(R6::is.R6(x)))
        self$`collections` <- `collections`
      }
    },
    toJSON = function() {
      InlineResponse2005Object <- list()
      if (!is.null(self$`collections`)) {
        InlineResponse2005Object[['collections']] <-
          lapply(self$`collections`, function(x) x$toJSON())
      }

      InlineResponse2005Object
    },
    fromJSON = function(InlineResponse2005Json) {
      InlineResponse2005Object <- jsonlite::fromJSON(InlineResponse2005Json)
      if (!is.null(InlineResponse2005Object$`collections`)) {
        self$`collections` <- ApiClient$new()$deserializeObj(InlineResponse2005Object$`collections`, "array[CollectionOfCollectionsItem]", "package:HCAClient")
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`collections`)) {
        sprintf(
        '"collections":
        [%s]
',
        paste(sapply(self$`collections`, function(x) jsonlite::toJSON(x$toJSON(), auto_unbox=TRUE, digits = NA)), collapse=",")
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2005Json) {
      InlineResponse2005Object <- jsonlite::fromJSON(InlineResponse2005Json)
      self$`collections` <- ApiClient$new()$deserializeObj(InlineResponse2005Object$`collections`, "array[CollectionOfCollectionsItem]","package:HCAClient")
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2006
#' @description InlineResponse2006 Class
#' @format An \code{R6Class} generator object
#' @field collection   \link[HCAClient:Collection]{  Collection  }  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2006 <- R6::R6Class(
  'InlineResponse2006',
  public = list(
    `collection` = NULL,
    initialize = function(`collection`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`collection`)) {
        stopifnot(R6::is.R6(`collection`))
        self$`collection` <- `collection`
      }
    },
    toJSON = function() {
      InlineResponse2006Object <- list()
      if (!is.null(self$`collection`)) {
        InlineResponse2006Object[['collection']] <-
          self$`collection`$toJSON()
      }

      InlineResponse2006Object
    },
    fromJSON = function(InlineResponse2006Json) {
      InlineResponse2006Object <- jsonlite::fromJSON(InlineResponse2006Json)
      if (!is.null(InlineResponse2006Object$`collection`)) {
        collectionObject <- Collection$new()
        collectionObject$fromJSON(jsonlite::toJSON(InlineResponse2006Object$collection, auto_unbox = TRUE, digits = NA))
        self$`collection` <- collectionObject
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`collection`)) {
        sprintf(
        '"collection":
        %s
        ',
        jsonlite::toJSON(self$`collection`$toJSON(), auto_unbox=TRUE, digits = NA)
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2006Json) {
      InlineResponse2006Object <- jsonlite::fromJSON(InlineResponse2006Json)
      self$`collection` <- Collection$new()$fromJSON(jsonlite::toJSON(InlineResponse2006Object$collection, auto_unbox = TRUE, digits = NA))
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2007
#' @description InlineResponse2007 Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2007 <- R6::R6Class(
  'InlineResponse2007',
  public = list(
    `uuid` = NULL,
    `version` = NULL,
    initialize = function(`uuid`, `version`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      InlineResponse2007Object <- list()
      if (!is.null(self$`uuid`)) {
        InlineResponse2007Object[['uuid']] <-
          self$`uuid`
      }
      if (!is.null(self$`version`)) {
        InlineResponse2007Object[['version']] <-
          self$`version`
      }

      InlineResponse2007Object
    },
    fromJSON = function(InlineResponse2007Json) {
      InlineResponse2007Object <- jsonlite::fromJSON(InlineResponse2007Json)
      if (!is.null(InlineResponse2007Object$`uuid`)) {
        self$`uuid` <- InlineResponse2007Object$`uuid`
      }
      if (!is.null(InlineResponse2007Object$`version`)) {
        self$`version` <- InlineResponse2007Object$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2007Json) {
      InlineResponse2007Object <- jsonlite::fromJSON(InlineResponse2007Json)
      self$`uuid` <- InlineResponse2007Object$`uuid`
      self$`version` <- InlineResponse2007Object$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2008
#' @description InlineResponse2008 Class
#' @format An \code{R6Class} generator object
#' @field manifest   \link[HCAClient:EventsManifest]{  EventsManifest  }  [optional]
#'
#' @field url   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2008 <- R6::R6Class(
  'InlineResponse2008',
  public = list(
    `manifest` = NULL,
    `url` = NULL,
    initialize = function(`manifest`=NULL, `url`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`manifest`)) {
        stopifnot(R6::is.R6(`manifest`))
        self$`manifest` <- `manifest`
      }
      if (!is.null(`url`)) {
        stopifnot(is.character(`url`), length(`url`) == 1)
        self$`url` <- `url`
      }
    },
    toJSON = function() {
      InlineResponse2008Object <- list()
      if (!is.null(self$`manifest`)) {
        InlineResponse2008Object[['manifest']] <-
          self$`manifest`$toJSON()
      }
      if (!is.null(self$`url`)) {
        InlineResponse2008Object[['url']] <-
          self$`url`
      }

      InlineResponse2008Object
    },
    fromJSON = function(InlineResponse2008Json) {
      InlineResponse2008Object <- jsonlite::fromJSON(InlineResponse2008Json)
      if (!is.null(InlineResponse2008Object$`manifest`)) {
        manifestObject <- EventsManifest$new()
        manifestObject$fromJSON(jsonlite::toJSON(InlineResponse2008Object$manifest, auto_unbox = TRUE, digits = NA))
        self$`manifest` <- manifestObject
      }
      if (!is.null(InlineResponse2008Object$`url`)) {
        self$`url` <- InlineResponse2008Object$`url`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`manifest`)) {
        sprintf(
        '"manifest":
        %s
        ',
        jsonlite::toJSON(self$`manifest`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`url`)) {
        sprintf(
        '"url":
          "%s"
                ',
        self$`url`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2008Json) {
      InlineResponse2008Object <- jsonlite::fromJSON(InlineResponse2008Json)
      self$`manifest` <- EventsManifest$new()$fromJSON(jsonlite::toJSON(InlineResponse2008Object$manifest, auto_unbox = TRUE, digits = NA))
      self$`url` <- InlineResponse2008Object$`url`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2009
#' @description InlineResponse2009 Class
#' @format An \code{R6Class} generator object
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2009 <- R6::R6Class(
  'InlineResponse2009',
  public = list(
    `version` = NULL,
    initialize = function(`version`, ...){
      local.optional.var <- list(...)
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
    },
    toJSON = function() {
      InlineResponse2009Object <- list()
      if (!is.null(self$`version`)) {
        InlineResponse2009Object[['version']] <-
          self$`version`
      }

      InlineResponse2009Object
    },
    fromJSON = function(InlineResponse2009Json) {
      InlineResponse2009Object <- jsonlite::fromJSON(InlineResponse2009Json)
      if (!is.null(InlineResponse2009Object$`version`)) {
        self$`version` <- InlineResponse2009Object$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2009Json) {
      InlineResponse2009Object <- jsonlite::fromJSON(InlineResponse2009Json)
      self$`version` <- InlineResponse2009Object$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse201
#' @description InlineResponse201 Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse201 <- R6::R6Class(
  'InlineResponse201',
  public = list(
    `uuid` = NULL,
    initialize = function(`uuid`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
    },
    toJSON = function() {
      InlineResponse201Object <- list()
      if (!is.null(self$`uuid`)) {
        InlineResponse201Object[['uuid']] <-
          self$`uuid`
      }

      InlineResponse201Object
    },
    fromJSON = function(InlineResponse201Json) {
      InlineResponse201Object <- jsonlite::fromJSON(InlineResponse201Json)
      if (!is.null(InlineResponse201Object$`uuid`)) {
        self$`uuid` <- InlineResponse201Object$`uuid`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse201Json) {
      InlineResponse201Object <- jsonlite::fromJSON(InlineResponse201Json)
      self$`uuid` <- InlineResponse201Object$`uuid`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse2011
#' @description InlineResponse2011 Class
#' @format An \code{R6Class} generator object
#' @field uuid   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse2011 <- R6::R6Class(
  'InlineResponse2011',
  public = list(
    `uuid` = NULL,
    initialize = function(`uuid`, ...){
      local.optional.var <- list(...)
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
    },
    toJSON = function() {
      InlineResponse2011Object <- list()
      if (!is.null(self$`uuid`)) {
        InlineResponse2011Object[['uuid']] <-
          self$`uuid`
      }

      InlineResponse2011Object
    },
    fromJSON = function(InlineResponse2011Json) {
      InlineResponse2011Object <- jsonlite::fromJSON(InlineResponse2011Json)
      if (!is.null(InlineResponse2011Object$`uuid`)) {
        self$`uuid` <- InlineResponse2011Object$`uuid`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse2011Json) {
      InlineResponse2011Object <- jsonlite::fromJSON(InlineResponse2011Json)
      self$`uuid` <- InlineResponse2011Object$`uuid`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse202
#' @description InlineResponse202 Class
#' @format An \code{R6Class} generator object
#' @field task_id   character  [optional]
#'
#' @field version   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse202 <- R6::R6Class(
  'InlineResponse202',
  public = list(
    `task_id` = NULL,
    `version` = NULL,
    initialize = function(`version`, `task_id`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`version`)) {
        stopifnot(is.character(`version`), length(`version`) == 1)
        self$`version` <- `version`
      }
      if (!is.null(`task_id`)) {
        stopifnot(is.character(`task_id`), length(`task_id`) == 1)
        self$`task_id` <- `task_id`
      }
    },
    toJSON = function() {
      InlineResponse202Object <- list()
      if (!is.null(self$`task_id`)) {
        InlineResponse202Object[['task_id']] <-
          self$`task_id`
      }
      if (!is.null(self$`version`)) {
        InlineResponse202Object[['version']] <-
          self$`version`
      }

      InlineResponse202Object
    },
    fromJSON = function(InlineResponse202Json) {
      InlineResponse202Object <- jsonlite::fromJSON(InlineResponse202Json)
      if (!is.null(InlineResponse202Object$`task_id`)) {
        self$`task_id` <- InlineResponse202Object$`task_id`
      }
      if (!is.null(InlineResponse202Object$`version`)) {
        self$`version` <- InlineResponse202Object$`version`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`task_id`)) {
        sprintf(
        '"task_id":
          "%s"
                ',
        self$`task_id`
        )},
        if (!is.null(self$`version`)) {
        sprintf(
        '"version":
          "%s"
                ',
        self$`version`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse202Json) {
      InlineResponse202Object <- jsonlite::fromJSON(InlineResponse202Json)
      self$`task_id` <- InlineResponse202Object$`task_id`
      self$`version` <- InlineResponse202Object$`version`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse400
#' @description InlineResponse400 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse400 <- R6::R6Class(
  'InlineResponse400',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse400Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse400Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse400Object[['code']] <-
          self$`code`
      }

      InlineResponse400Object
    },
    fromJSON = function(InlineResponse400Json) {
      InlineResponse400Object <- jsonlite::fromJSON(InlineResponse400Json)
      if (!is.null(InlineResponse400Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse400Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse400Object$`code`)) {
        self$`code` <- InlineResponse400Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse400Json) {
      InlineResponse400Object <- jsonlite::fromJSON(InlineResponse400Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse400Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse400Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4001
#' @description InlineResponse4001 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4001 <- R6::R6Class(
  'InlineResponse4001',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4001Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4001Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4001Object[['code']] <-
          self$`code`
      }

      InlineResponse4001Object
    },
    fromJSON = function(InlineResponse4001Json) {
      InlineResponse4001Object <- jsonlite::fromJSON(InlineResponse4001Json)
      if (!is.null(InlineResponse4001Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4001Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4001Object$`code`)) {
        self$`code` <- InlineResponse4001Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4001Json) {
      InlineResponse4001Object <- jsonlite::fromJSON(InlineResponse4001Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4001Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4001Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4002
#' @description InlineResponse4002 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4002 <- R6::R6Class(
  'InlineResponse4002',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4002Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4002Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4002Object[['code']] <-
          self$`code`
      }

      InlineResponse4002Object
    },
    fromJSON = function(InlineResponse4002Json) {
      InlineResponse4002Object <- jsonlite::fromJSON(InlineResponse4002Json)
      if (!is.null(InlineResponse4002Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4002Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4002Object$`code`)) {
        self$`code` <- InlineResponse4002Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4002Json) {
      InlineResponse4002Object <- jsonlite::fromJSON(InlineResponse4002Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4002Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4002Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4003
#' @description InlineResponse4003 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4003 <- R6::R6Class(
  'InlineResponse4003',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4003Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4003Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4003Object[['code']] <-
          self$`code`
      }

      InlineResponse4003Object
    },
    fromJSON = function(InlineResponse4003Json) {
      InlineResponse4003Object <- jsonlite::fromJSON(InlineResponse4003Json)
      if (!is.null(InlineResponse4003Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4003Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4003Object$`code`)) {
        self$`code` <- InlineResponse4003Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4003Json) {
      InlineResponse4003Object <- jsonlite::fromJSON(InlineResponse4003Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4003Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4003Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4004
#' @description InlineResponse4004 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4004 <- R6::R6Class(
  'InlineResponse4004',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4004Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4004Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4004Object[['code']] <-
          self$`code`
      }

      InlineResponse4004Object
    },
    fromJSON = function(InlineResponse4004Json) {
      InlineResponse4004Object <- jsonlite::fromJSON(InlineResponse4004Json)
      if (!is.null(InlineResponse4004Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4004Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4004Object$`code`)) {
        self$`code` <- InlineResponse4004Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4004Json) {
      InlineResponse4004Object <- jsonlite::fromJSON(InlineResponse4004Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4004Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4004Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4005
#' @description InlineResponse4005 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4005 <- R6::R6Class(
  'InlineResponse4005',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4005Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4005Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4005Object[['code']] <-
          self$`code`
      }

      InlineResponse4005Object
    },
    fromJSON = function(InlineResponse4005Json) {
      InlineResponse4005Object <- jsonlite::fromJSON(InlineResponse4005Json)
      if (!is.null(InlineResponse4005Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4005Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4005Object$`code`)) {
        self$`code` <- InlineResponse4005Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4005Json) {
      InlineResponse4005Object <- jsonlite::fromJSON(InlineResponse4005Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4005Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4005Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse401
#' @description InlineResponse401 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse401 <- R6::R6Class(
  'InlineResponse401',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse401Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse401Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse401Object[['code']] <-
          self$`code`
      }

      InlineResponse401Object
    },
    fromJSON = function(InlineResponse401Json) {
      InlineResponse401Object <- jsonlite::fromJSON(InlineResponse401Json)
      if (!is.null(InlineResponse401Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse401Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse401Object$`code`)) {
        self$`code` <- InlineResponse401Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse401Json) {
      InlineResponse401Object <- jsonlite::fromJSON(InlineResponse401Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse401Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse401Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse403
#' @description InlineResponse403 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse403 <- R6::R6Class(
  'InlineResponse403',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse403Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse403Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse403Object[['code']] <-
          self$`code`
      }

      InlineResponse403Object
    },
    fromJSON = function(InlineResponse403Json) {
      InlineResponse403Object <- jsonlite::fromJSON(InlineResponse403Json)
      if (!is.null(InlineResponse403Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse403Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse403Object$`code`)) {
        self$`code` <- InlineResponse403Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse403Json) {
      InlineResponse403Object <- jsonlite::fromJSON(InlineResponse403Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse403Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse403Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4031
#' @description InlineResponse4031 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4031 <- R6::R6Class(
  'InlineResponse4031',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4031Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4031Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4031Object[['code']] <-
          self$`code`
      }

      InlineResponse4031Object
    },
    fromJSON = function(InlineResponse4031Json) {
      InlineResponse4031Object <- jsonlite::fromJSON(InlineResponse4031Json)
      if (!is.null(InlineResponse4031Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4031Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4031Object$`code`)) {
        self$`code` <- InlineResponse4031Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4031Json) {
      InlineResponse4031Object <- jsonlite::fromJSON(InlineResponse4031Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4031Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4031Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4032
#' @description InlineResponse4032 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4032 <- R6::R6Class(
  'InlineResponse4032',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4032Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4032Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4032Object[['code']] <-
          self$`code`
      }

      InlineResponse4032Object
    },
    fromJSON = function(InlineResponse4032Json) {
      InlineResponse4032Object <- jsonlite::fromJSON(InlineResponse4032Json)
      if (!is.null(InlineResponse4032Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4032Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4032Object$`code`)) {
        self$`code` <- InlineResponse4032Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4032Json) {
      InlineResponse4032Object <- jsonlite::fromJSON(InlineResponse4032Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4032Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4032Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse404
#' @description InlineResponse404 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#' @field message   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse404 <- R6::R6Class(
  'InlineResponse404',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    `message` = NULL,
    initialize = function(`code`, `Error`=NULL, `message`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
      if (!is.null(`message`)) {
        stopifnot(is.character(`message`), length(`message`) == 1)
        self$`message` <- `message`
      }
    },
    toJSON = function() {
      InlineResponse404Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse404Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse404Object[['code']] <-
          self$`code`
      }
      if (!is.null(self$`message`)) {
        InlineResponse404Object[['message']] <-
          self$`message`
      }

      InlineResponse404Object
    },
    fromJSON = function(InlineResponse404Json) {
      InlineResponse404Object <- jsonlite::fromJSON(InlineResponse404Json)
      if (!is.null(InlineResponse404Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse404Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse404Object$`code`)) {
        self$`code` <- InlineResponse404Object$`code`
      }
      if (!is.null(InlineResponse404Object$`message`)) {
        self$`message` <- InlineResponse404Object$`message`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )},
        if (!is.null(self$`message`)) {
        sprintf(
        '"message":
          "%s"
                ',
        self$`message`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse404Json) {
      InlineResponse404Object <- jsonlite::fromJSON(InlineResponse404Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse404Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse404Object$`code`
      self$`message` <- InlineResponse404Object$`message`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4041
#' @description InlineResponse4041 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4041 <- R6::R6Class(
  'InlineResponse4041',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4041Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4041Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4041Object[['code']] <-
          self$`code`
      }

      InlineResponse4041Object
    },
    fromJSON = function(InlineResponse4041Json) {
      InlineResponse4041Object <- jsonlite::fromJSON(InlineResponse4041Json)
      if (!is.null(InlineResponse4041Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4041Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4041Object$`code`)) {
        self$`code` <- InlineResponse4041Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4041Json) {
      InlineResponse4041Object <- jsonlite::fromJSON(InlineResponse4041Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4041Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4041Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse409
#' @description InlineResponse409 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse409 <- R6::R6Class(
  'InlineResponse409',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse409Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse409Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse409Object[['code']] <-
          self$`code`
      }

      InlineResponse409Object
    },
    fromJSON = function(InlineResponse409Json) {
      InlineResponse409Object <- jsonlite::fromJSON(InlineResponse409Json)
      if (!is.null(InlineResponse409Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse409Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse409Object$`code`)) {
        self$`code` <- InlineResponse409Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse409Json) {
      InlineResponse409Object <- jsonlite::fromJSON(InlineResponse409Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse409Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse409Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4091
#' @description InlineResponse4091 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4091 <- R6::R6Class(
  'InlineResponse4091',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4091Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4091Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4091Object[['code']] <-
          self$`code`
      }

      InlineResponse4091Object
    },
    fromJSON = function(InlineResponse4091Json) {
      InlineResponse4091Object <- jsonlite::fromJSON(InlineResponse4091Json)
      if (!is.null(InlineResponse4091Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4091Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4091Object$`code`)) {
        self$`code` <- InlineResponse4091Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4091Json) {
      InlineResponse4091Object <- jsonlite::fromJSON(InlineResponse4091Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4091Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4091Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4092
#' @description InlineResponse4092 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4092 <- R6::R6Class(
  'InlineResponse4092',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4092Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4092Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4092Object[['code']] <-
          self$`code`
      }

      InlineResponse4092Object
    },
    fromJSON = function(InlineResponse4092Json) {
      InlineResponse4092Object <- jsonlite::fromJSON(InlineResponse4092Json)
      if (!is.null(InlineResponse4092Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4092Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4092Object$`code`)) {
        self$`code` <- InlineResponse4092Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4092Json) {
      InlineResponse4092Object <- jsonlite::fromJSON(InlineResponse4092Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4092Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4092Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse422
#' @description InlineResponse422 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse422 <- R6::R6Class(
  'InlineResponse422',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse422Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse422Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse422Object[['code']] <-
          self$`code`
      }

      InlineResponse422Object
    },
    fromJSON = function(InlineResponse422Json) {
      InlineResponse422Object <- jsonlite::fromJSON(InlineResponse422Json)
      if (!is.null(InlineResponse422Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse422Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse422Object$`code`)) {
        self$`code` <- InlineResponse422Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse422Json) {
      InlineResponse422Object <- jsonlite::fromJSON(InlineResponse422Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse422Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse422Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse4221
#' @description InlineResponse4221 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse4221 <- R6::R6Class(
  'InlineResponse4221',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse4221Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse4221Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse4221Object[['code']] <-
          self$`code`
      }

      InlineResponse4221Object
    },
    fromJSON = function(InlineResponse4221Json) {
      InlineResponse4221Object <- jsonlite::fromJSON(InlineResponse4221Json)
      if (!is.null(InlineResponse4221Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse4221Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse4221Object$`code`)) {
        self$`code` <- InlineResponse4221Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse4221Json) {
      InlineResponse4221Object <- jsonlite::fromJSON(InlineResponse4221Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse4221Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse4221Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse500
#' @description InlineResponse500 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse500 <- R6::R6Class(
  'InlineResponse500',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse500Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse500Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse500Object[['code']] <-
          self$`code`
      }

      InlineResponse500Object
    },
    fromJSON = function(InlineResponse500Json) {
      InlineResponse500Object <- jsonlite::fromJSON(InlineResponse500Json)
      if (!is.null(InlineResponse500Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse500Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse500Object$`code`)) {
        self$`code` <- InlineResponse500Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse500Json) {
      InlineResponse500Object <- jsonlite::fromJSON(InlineResponse500Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse500Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse500Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponse503
#' @description InlineResponse503 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponse503 <- R6::R6Class(
  'InlineResponse503',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponse503Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponse503Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponse503Object[['code']] <-
          self$`code`
      }

      InlineResponse503Object
    },
    fromJSON = function(InlineResponse503Json) {
      InlineResponse503Object <- jsonlite::fromJSON(InlineResponse503Json)
      if (!is.null(InlineResponse503Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponse503Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponse503Object$`code`)) {
        self$`code` <- InlineResponse503Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponse503Json) {
      InlineResponse503Object <- jsonlite::fromJSON(InlineResponse503Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponse503Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponse503Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault
#' @description InlineResponseDefault Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#' @field message   character  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault <- R6::R6Class(
  'InlineResponseDefault',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    `message` = NULL,
    initialize = function(`code`, `Error`=NULL, `message`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
      if (!is.null(`message`)) {
        stopifnot(is.character(`message`), length(`message`) == 1)
        self$`message` <- `message`
      }
    },
    toJSON = function() {
      InlineResponseDefaultObject <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefaultObject[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefaultObject[['code']] <-
          self$`code`
      }
      if (!is.null(self$`message`)) {
        InlineResponseDefaultObject[['message']] <-
          self$`message`
      }

      InlineResponseDefaultObject
    },
    fromJSON = function(InlineResponseDefaultJson) {
      InlineResponseDefaultObject <- jsonlite::fromJSON(InlineResponseDefaultJson)
      if (!is.null(InlineResponseDefaultObject$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefaultObject$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefaultObject$`code`)) {
        self$`code` <- InlineResponseDefaultObject$`code`
      }
      if (!is.null(InlineResponseDefaultObject$`message`)) {
        self$`message` <- InlineResponseDefaultObject$`message`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )},
        if (!is.null(self$`message`)) {
        sprintf(
        '"message":
          "%s"
                ',
        self$`message`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefaultJson) {
      InlineResponseDefaultObject <- jsonlite::fromJSON(InlineResponseDefaultJson)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefaultObject$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefaultObject$`code`
      self$`message` <- InlineResponseDefaultObject$`message`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault1
#' @description InlineResponseDefault1 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault1 <- R6::R6Class(
  'InlineResponseDefault1',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault1Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault1Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault1Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault1Object
    },
    fromJSON = function(InlineResponseDefault1Json) {
      InlineResponseDefault1Object <- jsonlite::fromJSON(InlineResponseDefault1Json)
      if (!is.null(InlineResponseDefault1Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault1Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault1Object$`code`)) {
        self$`code` <- InlineResponseDefault1Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault1Json) {
      InlineResponseDefault1Object <- jsonlite::fromJSON(InlineResponseDefault1Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault1Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault1Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault10
#' @description InlineResponseDefault10 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault10 <- R6::R6Class(
  'InlineResponseDefault10',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault10Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault10Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault10Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault10Object
    },
    fromJSON = function(InlineResponseDefault10Json) {
      InlineResponseDefault10Object <- jsonlite::fromJSON(InlineResponseDefault10Json)
      if (!is.null(InlineResponseDefault10Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault10Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault10Object$`code`)) {
        self$`code` <- InlineResponseDefault10Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault10Json) {
      InlineResponseDefault10Object <- jsonlite::fromJSON(InlineResponseDefault10Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault10Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault10Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault2
#' @description InlineResponseDefault2 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault2 <- R6::R6Class(
  'InlineResponseDefault2',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault2Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault2Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault2Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault2Object
    },
    fromJSON = function(InlineResponseDefault2Json) {
      InlineResponseDefault2Object <- jsonlite::fromJSON(InlineResponseDefault2Json)
      if (!is.null(InlineResponseDefault2Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault2Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault2Object$`code`)) {
        self$`code` <- InlineResponseDefault2Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault2Json) {
      InlineResponseDefault2Object <- jsonlite::fromJSON(InlineResponseDefault2Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault2Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault2Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault3
#' @description InlineResponseDefault3 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault3 <- R6::R6Class(
  'InlineResponseDefault3',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault3Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault3Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault3Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault3Object
    },
    fromJSON = function(InlineResponseDefault3Json) {
      InlineResponseDefault3Object <- jsonlite::fromJSON(InlineResponseDefault3Json)
      if (!is.null(InlineResponseDefault3Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault3Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault3Object$`code`)) {
        self$`code` <- InlineResponseDefault3Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault3Json) {
      InlineResponseDefault3Object <- jsonlite::fromJSON(InlineResponseDefault3Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault3Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault3Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault4
#' @description InlineResponseDefault4 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault4 <- R6::R6Class(
  'InlineResponseDefault4',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault4Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault4Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault4Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault4Object
    },
    fromJSON = function(InlineResponseDefault4Json) {
      InlineResponseDefault4Object <- jsonlite::fromJSON(InlineResponseDefault4Json)
      if (!is.null(InlineResponseDefault4Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault4Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault4Object$`code`)) {
        self$`code` <- InlineResponseDefault4Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault4Json) {
      InlineResponseDefault4Object <- jsonlite::fromJSON(InlineResponseDefault4Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault4Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault4Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault5
#' @description InlineResponseDefault5 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault5 <- R6::R6Class(
  'InlineResponseDefault5',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault5Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault5Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault5Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault5Object
    },
    fromJSON = function(InlineResponseDefault5Json) {
      InlineResponseDefault5Object <- jsonlite::fromJSON(InlineResponseDefault5Json)
      if (!is.null(InlineResponseDefault5Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault5Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault5Object$`code`)) {
        self$`code` <- InlineResponseDefault5Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault5Json) {
      InlineResponseDefault5Object <- jsonlite::fromJSON(InlineResponseDefault5Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault5Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault5Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault6
#' @description InlineResponseDefault6 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault6 <- R6::R6Class(
  'InlineResponseDefault6',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault6Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault6Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault6Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault6Object
    },
    fromJSON = function(InlineResponseDefault6Json) {
      InlineResponseDefault6Object <- jsonlite::fromJSON(InlineResponseDefault6Json)
      if (!is.null(InlineResponseDefault6Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault6Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault6Object$`code`)) {
        self$`code` <- InlineResponseDefault6Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault6Json) {
      InlineResponseDefault6Object <- jsonlite::fromJSON(InlineResponseDefault6Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault6Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault6Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault7
#' @description InlineResponseDefault7 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault7 <- R6::R6Class(
  'InlineResponseDefault7',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault7Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault7Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault7Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault7Object
    },
    fromJSON = function(InlineResponseDefault7Json) {
      InlineResponseDefault7Object <- jsonlite::fromJSON(InlineResponseDefault7Json)
      if (!is.null(InlineResponseDefault7Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault7Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault7Object$`code`)) {
        self$`code` <- InlineResponseDefault7Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault7Json) {
      InlineResponseDefault7Object <- jsonlite::fromJSON(InlineResponseDefault7Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault7Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault7Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault8
#' @description InlineResponseDefault8 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault8 <- R6::R6Class(
  'InlineResponseDefault8',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault8Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault8Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault8Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault8Object
    },
    fromJSON = function(InlineResponseDefault8Json) {
      InlineResponseDefault8Object <- jsonlite::fromJSON(InlineResponseDefault8Json)
      if (!is.null(InlineResponseDefault8Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault8Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault8Object$`code`)) {
        self$`code` <- InlineResponseDefault8Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault8Json) {
      InlineResponseDefault8Object <- jsonlite::fromJSON(InlineResponseDefault8Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault8Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault8Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title InlineResponseDefault9
#' @description InlineResponseDefault9 Class
#' @format An \code{R6Class} generator object
#' @field Error   \link[HCAClient:Error]{  Error  }  [optional]
#'
#' @field code   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
InlineResponseDefault9 <- R6::R6Class(
  'InlineResponseDefault9',
  public = list(
    `Error` = NULL,
    `code` = NULL,
    initialize = function(`code`, `Error`=NULL, ...){
      local.optional.var <- list(...)
      if (!missing(`code`)) {
        stopifnot(is.character(`code`), length(`code`) == 1)
        self$`code` <- `code`
      }
      if (!is.null(`Error`)) {
        stopifnot(R6::is.R6(`Error`))
        self$`Error` <- `Error`
      }
    },
    toJSON = function() {
      InlineResponseDefault9Object <- list()
      if (!is.null(self$`Error`)) {
        InlineResponseDefault9Object[['Error']] <-
          self$`Error`$toJSON()
      }
      if (!is.null(self$`code`)) {
        InlineResponseDefault9Object[['code']] <-
          self$`code`
      }

      InlineResponseDefault9Object
    },
    fromJSON = function(InlineResponseDefault9Json) {
      InlineResponseDefault9Object <- jsonlite::fromJSON(InlineResponseDefault9Json)
      if (!is.null(InlineResponseDefault9Object$`Error`)) {
        ErrorObject <- Error$new()
        ErrorObject$fromJSON(jsonlite::toJSON(InlineResponseDefault9Object$Error, auto_unbox = TRUE, digits = NA))
        self$`Error` <- ErrorObject
      }
      if (!is.null(InlineResponseDefault9Object$`code`)) {
        self$`code` <- InlineResponseDefault9Object$`code`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`Error`)) {
        sprintf(
        '"Error":
        %s
        ',
        jsonlite::toJSON(self$`Error`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`code`)) {
        sprintf(
        '"code":
          "%s"
                ',
        self$`code`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(InlineResponseDefault9Json) {
      InlineResponseDefault9Object <- jsonlite::fromJSON(InlineResponseDefault9Json)
      self$`Error` <- Error$new()$fromJSON(jsonlite::toJSON(InlineResponseDefault9Object$Error, auto_unbox = TRUE, digits = NA))
      self$`code` <- InlineResponseDefault9Object$`code`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title SearchResult
#' @description SearchResult Class
#' @format An \code{R6Class} generator object
#' @field es_query   \link[HCAClient:]{  object  }  [optional]
#'
#' @field results    list(object)   [optional]
#'
#' @field total_hits   integer  [optional]
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
SearchResult <- R6::R6Class(
  'SearchResult',
  public = list(
    `es_query` = NULL,
    `results` = NULL,
    `total_hits` = NULL,
    initialize = function(`es_query`=NULL, `results`=NULL, `total_hits`=NULL, ...){
      local.optional.var <- list(...)
      if (!is.null(`es_query`)) {
        stopifnot(R6::is.R6(`es_query`))
        self$`es_query` <- `es_query`
      }
      if (!is.null(`results`)) {
        stopifnot(is.vector(`results`), length(`results`) != 0)
        sapply(`results`, function(x) stopifnot(is.character(x)))
        self$`results` <- `results`
      }
      if (!is.null(`total_hits`)) {
        stopifnot(is.numeric(`total_hits`), length(`total_hits`) == 1)
        self$`total_hits` <- `total_hits`
      }
    },
    toJSON = function() {
      SearchResultObject <- list()
      if (!is.null(self$`es_query`)) {
        SearchResultObject[['es_query']] <-
          self$`es_query`$toJSON()
      }
      if (!is.null(self$`results`)) {
        SearchResultObject[['results']] <-
          self$`results`
      }
      if (!is.null(self$`total_hits`)) {
        SearchResultObject[['total_hits']] <-
          self$`total_hits`
      }

      SearchResultObject
    },
    fromJSON = function(SearchResultJson) {
      SearchResultObject <- jsonlite::fromJSON(SearchResultJson)
      if (!is.null(SearchResultObject$`es_query`)) {
        es_queryObject <- object$new()
        es_queryObject$fromJSON(jsonlite::toJSON(SearchResultObject$es_query, auto_unbox = TRUE, digits = NA))
        self$`es_query` <- es_queryObject
      }
      if (!is.null(SearchResultObject$`results`)) {
        self$`results` <- ApiClient$new()$deserializeObj(SearchResultObject$`results`, "array[object]", "package:HCAClient")
      }
      if (!is.null(SearchResultObject$`total_hits`)) {
        self$`total_hits` <- SearchResultObject$`total_hits`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`es_query`)) {
        sprintf(
        '"es_query":
        %s
        ',
        jsonlite::toJSON(self$`es_query`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`results`)) {
        sprintf(
        '"results":
           [%s]
        ',
        paste(unlist(lapply(self$`results`, function(x) paste0('"', x, '"'))), collapse=",")
        )},
        if (!is.null(self$`total_hits`)) {
        sprintf(
        '"total_hits":
          %d
                ',
        self$`total_hits`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(SearchResultJson) {
      SearchResultObject <- jsonlite::fromJSON(SearchResultJson)
      self$`es_query` <- object$new()$fromJSON(jsonlite::toJSON(SearchResultObject$es_query, auto_unbox = TRUE, digits = NA))
      self$`results` <- ApiClient$new()$deserializeObj(SearchResultObject$`results`, "array[object]","package:HCAClient")
      self$`total_hits` <- SearchResultObject$`total_hits`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Subscription
#' @description Subscription Class
#' @format An \code{R6Class} generator object
#' @field attachments   \link[HCAClient:_subscriptions_attachments]{   named list(SubscriptionsAttachments)   }  [optional]
#'
#' @field callback_url   character  
#'
#' @field encoding   character  [optional]
#'
#' @field es_query   \link[HCAClient:]{  object  }  [optional]
#'
#' @field form_fields    named list(character)   [optional]
#'
#' @field hmac_key_id   character  [optional]
#'
#' @field jmespath_query   character  [optional]
#'
#' @field method   character  [optional]
#'
#' @field owner   character  
#'
#' @field payload_form_field   character  [optional]
#'
#' @field replica   character  
#'
#' @field uuid   character  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
Subscription <- R6::R6Class(
  'Subscription',
  public = list(
    `attachments` = NULL,
    `callback_url` = NULL,
    `encoding` = NULL,
    `es_query` = NULL,
    `form_fields` = NULL,
    `hmac_key_id` = NULL,
    `jmespath_query` = NULL,
    `method` = NULL,
    `owner` = NULL,
    `payload_form_field` = NULL,
    `replica` = NULL,
    `uuid` = NULL,
    initialize = function(`callback_url`, `owner`, `replica`, `uuid`, `attachments`=NULL, `encoding`='application/json', `es_query`=NULL, `form_fields`=NULL, `hmac_key_id`=NULL, `jmespath_query`=NULL, `method`='POST', `payload_form_field`='payload', ...){
      local.optional.var <- list(...)
      if (!missing(`callback_url`)) {
        stopifnot(is.character(`callback_url`), length(`callback_url`) == 1)
        self$`callback_url` <- `callback_url`
      }
      if (!missing(`owner`)) {
        stopifnot(is.character(`owner`), length(`owner`) == 1)
        self$`owner` <- `owner`
      }
      if (!missing(`replica`)) {
        stopifnot(is.character(`replica`), length(`replica`) == 1)
        self$`replica` <- `replica`
      }
      if (!missing(`uuid`)) {
        stopifnot(is.character(`uuid`), length(`uuid`) == 1)
        self$`uuid` <- `uuid`
      }
      if (!is.null(`attachments`)) {
        stopifnot(is.vector(`attachments`), length(`attachments`) != 0)
        sapply(`attachments`, function(x) stopifnot(R6::is.R6(x)))
        self$`attachments` <- `attachments`
      }
      if (!is.null(`encoding`)) {
        stopifnot(is.character(`encoding`), length(`encoding`) == 1)
        self$`encoding` <- `encoding`
      }
      if (!is.null(`es_query`)) {
        stopifnot(R6::is.R6(`es_query`))
        self$`es_query` <- `es_query`
      }
      if (!is.null(`form_fields`)) {
        stopifnot(is.vector(`form_fields`), length(`form_fields`) != 0)
        sapply(`form_fields`, function(x) stopifnot(is.character(x)))
        self$`form_fields` <- `form_fields`
      }
      if (!is.null(`hmac_key_id`)) {
        stopifnot(is.character(`hmac_key_id`), length(`hmac_key_id`) == 1)
        self$`hmac_key_id` <- `hmac_key_id`
      }
      if (!is.null(`jmespath_query`)) {
        stopifnot(is.character(`jmespath_query`), length(`jmespath_query`) == 1)
        self$`jmespath_query` <- `jmespath_query`
      }
      if (!is.null(`method`)) {
        stopifnot(is.character(`method`), length(`method`) == 1)
        self$`method` <- `method`
      }
      if (!is.null(`payload_form_field`)) {
        stopifnot(is.character(`payload_form_field`), length(`payload_form_field`) == 1)
        self$`payload_form_field` <- `payload_form_field`
      }
    },
    toJSON = function() {
      SubscriptionObject <- list()
      if (!is.null(self$`attachments`)) {
        SubscriptionObject[['attachments']] <-
          lapply(self$`attachments`, function(x) x$toJSON())
      }
      if (!is.null(self$`callback_url`)) {
        SubscriptionObject[['callback_url']] <-
          self$`callback_url`
      }
      if (!is.null(self$`encoding`)) {
        SubscriptionObject[['encoding']] <-
          self$`encoding`
      }
      if (!is.null(self$`es_query`)) {
        SubscriptionObject[['es_query']] <-
          self$`es_query`$toJSON()
      }
      if (!is.null(self$`form_fields`)) {
        SubscriptionObject[['form_fields']] <-
          self$`form_fields`
      }
      if (!is.null(self$`hmac_key_id`)) {
        SubscriptionObject[['hmac_key_id']] <-
          self$`hmac_key_id`
      }
      if (!is.null(self$`jmespath_query`)) {
        SubscriptionObject[['jmespath_query']] <-
          self$`jmespath_query`
      }
      if (!is.null(self$`method`)) {
        SubscriptionObject[['method']] <-
          self$`method`
      }
      if (!is.null(self$`owner`)) {
        SubscriptionObject[['owner']] <-
          self$`owner`
      }
      if (!is.null(self$`payload_form_field`)) {
        SubscriptionObject[['payload_form_field']] <-
          self$`payload_form_field`
      }
      if (!is.null(self$`replica`)) {
        SubscriptionObject[['replica']] <-
          self$`replica`
      }
      if (!is.null(self$`uuid`)) {
        SubscriptionObject[['uuid']] <-
          self$`uuid`
      }

      SubscriptionObject
    },
    fromJSON = function(SubscriptionJson) {
      SubscriptionObject <- jsonlite::fromJSON(SubscriptionJson)
      if (!is.null(SubscriptionObject$`attachments`)) {
        self$`attachments` <- ApiClient$new()$deserializeObj(SubscriptionObject$`attachments`, "map(SubscriptionsAttachments)", "package:HCAClient")
      }
      if (!is.null(SubscriptionObject$`callback_url`)) {
        self$`callback_url` <- SubscriptionObject$`callback_url`
      }
      if (!is.null(SubscriptionObject$`encoding`)) {
        self$`encoding` <- SubscriptionObject$`encoding`
      }
      if (!is.null(SubscriptionObject$`es_query`)) {
        es_queryObject <- object$new()
        es_queryObject$fromJSON(jsonlite::toJSON(SubscriptionObject$es_query, auto_unbox = TRUE, digits = NA))
        self$`es_query` <- es_queryObject
      }
      if (!is.null(SubscriptionObject$`form_fields`)) {
        self$`form_fields` <- ApiClient$new()$deserializeObj(SubscriptionObject$`form_fields`, "map(character)", "package:HCAClient")
      }
      if (!is.null(SubscriptionObject$`hmac_key_id`)) {
        self$`hmac_key_id` <- SubscriptionObject$`hmac_key_id`
      }
      if (!is.null(SubscriptionObject$`jmespath_query`)) {
        self$`jmespath_query` <- SubscriptionObject$`jmespath_query`
      }
      if (!is.null(SubscriptionObject$`method`)) {
        self$`method` <- SubscriptionObject$`method`
      }
      if (!is.null(SubscriptionObject$`owner`)) {
        self$`owner` <- SubscriptionObject$`owner`
      }
      if (!is.null(SubscriptionObject$`payload_form_field`)) {
        self$`payload_form_field` <- SubscriptionObject$`payload_form_field`
      }
      if (!is.null(SubscriptionObject$`replica`)) {
        self$`replica` <- SubscriptionObject$`replica`
      }
      if (!is.null(SubscriptionObject$`uuid`)) {
        self$`uuid` <- SubscriptionObject$`uuid`
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`attachments`)) {
        sprintf(
        '"attachments":
        %s
',
        jsonlite::toJSON(lapply(self$`attachments`, function(x){ x$toJSON() }), auto_unbox = TRUE, digits=NA)
        )},
        if (!is.null(self$`callback_url`)) {
        sprintf(
        '"callback_url":
          "%s"
                ',
        self$`callback_url`
        )},
        if (!is.null(self$`encoding`)) {
        sprintf(
        '"encoding":
          "%s"
                ',
        self$`encoding`
        )},
        if (!is.null(self$`es_query`)) {
        sprintf(
        '"es_query":
        %s
        ',
        jsonlite::toJSON(self$`es_query`$toJSON(), auto_unbox=TRUE, digits = NA)
        )},
        if (!is.null(self$`form_fields`)) {
        sprintf(
        '"form_fields":
          "%s"
        ',
        jsonlite::toJSON(lapply(self$`form_fields`, function(x){ x }), auto_unbox = TRUE, digits=NA)
        )},
        if (!is.null(self$`hmac_key_id`)) {
        sprintf(
        '"hmac_key_id":
          "%s"
                ',
        self$`hmac_key_id`
        )},
        if (!is.null(self$`jmespath_query`)) {
        sprintf(
        '"jmespath_query":
          "%s"
                ',
        self$`jmespath_query`
        )},
        if (!is.null(self$`method`)) {
        sprintf(
        '"method":
          "%s"
                ',
        self$`method`
        )},
        if (!is.null(self$`owner`)) {
        sprintf(
        '"owner":
          "%s"
                ',
        self$`owner`
        )},
        if (!is.null(self$`payload_form_field`)) {
        sprintf(
        '"payload_form_field":
          "%s"
                ',
        self$`payload_form_field`
        )},
        if (!is.null(self$`replica`)) {
        sprintf(
        '"replica":
          "%s"
                ',
        self$`replica`
        )},
        if (!is.null(self$`uuid`)) {
        sprintf(
        '"uuid":
          "%s"
                ',
        self$`uuid`
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(SubscriptionJson) {
      SubscriptionObject <- jsonlite::fromJSON(SubscriptionJson)
      self$`attachments` <- ApiClient$new()$deserializeObj(SubscriptionObject$`attachments`, "map(SubscriptionsAttachments)","package:HCAClient")
      self$`callback_url` <- SubscriptionObject$`callback_url`
      self$`encoding` <- SubscriptionObject$`encoding`
      self$`es_query` <- object$new()$fromJSON(jsonlite::toJSON(SubscriptionObject$es_query, auto_unbox = TRUE, digits = NA))
      self$`form_fields` <- ApiClient$new()$deserializeObj(SubscriptionObject$`form_fields`, "map(character)","package:HCAClient")
      self$`hmac_key_id` <- SubscriptionObject$`hmac_key_id`
      self$`jmespath_query` <- SubscriptionObject$`jmespath_query`
      self$`method` <- SubscriptionObject$`method`
      self$`owner` <- SubscriptionObject$`owner`
      self$`payload_form_field` <- SubscriptionObject$`payload_form_field`
      self$`replica` <- SubscriptionObject$`replica`
      self$`uuid` <- SubscriptionObject$`uuid`
      self
    }
  )
)
# HCA DCP DSS API
#
# Human Cell Atlas Data Coordination Platform Data Storage System API # HTTP semantics The DSS API requires clients to follow certain HTTP protocol semantics that may require extra configuration in your HTTP client. The reference CLI and SDK (https://hca.readthedocs.io/) is pre-configured to do this. If writing your own client, please note the following:  **301 redirects**: Some DSS API routes may return one or more HTTP 301 redirects, including potentially redirects to themselves (combined with the **Retry-After** delay described below). The client must follow these redirects to obtain the resource requested.  **Retry-After header**: Some DSS API routes may use the **Retry-After** header in combination with HTTP 301 or 500 series response codes. The client must follow the HTTP specification and wait the designated time period before continuing with the next request.  **General retry logic**: If you are building an application that will issue high numbers of API requests, you should be prepared for the possibility that a small fraction of requests fails due to network or server errors. In these situations, the HTTP client should follow best practice HTTP retry semantics. For example, clients may be configured to retry 5 times while waiting for an exponential number of seconds (1, 2, 4, 8, 16 seconds) upon encountering any 500 series response code, connect or read timeout.  The following Python code demonstrates an example configuration of the popular Requests library per the above guidance: ``` import requests, requests.packages.urllib3.util.retry class RetryPolicy(requests.packages.urllib3.util.retry.Retry):     def __init__(self, retry_after_status_codes={301}, **kwargs):         super(RetryPolicy, self).__init__(**kwargs)         self.RETRY_AFTER_STATUS_CODES = frozenset(retry_after_status_codes | retry.Retry.RETRY_AFTER_STATUS_CODES)  retry_policy = RetryPolicy(read=5, status=5, status_forcelist=frozenset({500, 502, 503, 504})) s = requests.Session() a = requests.adapters.HTTPAdapter(max_retries=retry_policy) s.mount('https://', a) print(s.get(\"https://dss.data.humancellatlas.org\").content) ``` # Subscriptions DSS supports webhook subscriptions for data events like bundle creation and deletion. Webhooks are callbacks to a public HTTPS endpoint provided by your application. When an event matching your subscription occurs, DSS will send a push notification (via an HTTPS POST or PUT request), giving your application an up-to-date stream of system activity. Subscriptions are delivered with the payload format ``` {   'transaction_id': {uuid},   'subscription_id': {uuid},   'event_type': \"CREATE\"|\"TOMBSTONE\"|\"DELETE\",  # JMESPath subscriptions only   'match': {     'bundle_uuid': {uuid},     'bundle_version': {version},   }   'jmespath_query': {jmespath_query},  # JMESPath subscriptions only   'es_query': {es_query},  # Elasticsearch subscriptions only   'attachments': {     \"attachment_name_1\": {value},     \"attachment_name_1\": {value},     ...     \"_errors\": [...]   } } ```  # Special String Formats **DSS_VERSION**: a timestamp that generally follows [RFC3339](https://tools.ietf.org/html/rfc3339#section-5.6) format guide. However there are a few differences. DSS_VERSION must always be in UTC time, ':' are removed from the time, and the fractional seconds extends to 6 decimal places. Using the first example found [here](https://tools.ietf.org/html/rfc3339#section-5.8), the RFC3339 version would be `1985-04-12T23:20:50.52Z` while the DSS_VERSION would be `1985-04-12T232050.520000Z` # Pagination The DSS API supports pagination in a manner consistent with the [GitHub API](https://developer.github.com/v3/guides/traversing-with-pagination/), which is based on [RFC 5988](https://tools.ietf.org/html/rfc5988). When the results of an API call exceed the page size specified, the HTTP response will contain a `Link` header of the following form: `Link: <https://dss.data.humancellatlas.org/v1/search?replica=aws&per_page=100&search_after=123>; rel=\"next\"`. The URL in the header refers to the next page of the results to be fetched; if no `Link rel=\"next\"` URL is included, then all results have been fetched. The client should recognize and parse the `Link` header appropriately according to RFC 5988, and retrieve the next page if requested by the user, or if all results are being retrieved. 
#
# The version of the OpenAPI document: 0.0.2
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title SubscriptionsAttachments
#' @description SubscriptionsAttachments Class
#' @format An \code{R6Class} generator object
#' @field expression   character  
#'
#' @field type   \link[HCAClient:]{  object  }  
#'
#'
#' @importFrom R6 R6Class
#' @importFrom jsonlite fromJSON toJSON
#' @export
SubscriptionsAttachments <- R6::R6Class(
  'SubscriptionsAttachments',
  public = list(
    `expression` = NULL,
    `type` = NULL,
    initialize = function(`expression`, `type`, ...){
      local.optional.var <- list(...)
      if (!missing(`expression`)) {
        stopifnot(is.character(`expression`), length(`expression`) == 1)
        self$`expression` <- `expression`
      }
      if (!missing(`type`)) {
        stopifnot(R6::is.R6(`type`))
        self$`type` <- `type`
      }
    },
    toJSON = function() {
      SubscriptionsAttachmentsObject <- list()
      if (!is.null(self$`expression`)) {
        SubscriptionsAttachmentsObject[['expression']] <-
          self$`expression`
      }
      if (!is.null(self$`type`)) {
        SubscriptionsAttachmentsObject[['type']] <-
          self$`type`$toJSON()
      }

      SubscriptionsAttachmentsObject
    },
    fromJSON = function(SubscriptionsAttachmentsJson) {
      SubscriptionsAttachmentsObject <- jsonlite::fromJSON(SubscriptionsAttachmentsJson)
      if (!is.null(SubscriptionsAttachmentsObject$`expression`)) {
        self$`expression` <- SubscriptionsAttachmentsObject$`expression`
      }
      if (!is.null(SubscriptionsAttachmentsObject$`type`)) {
        typeObject <- object$new()
        typeObject$fromJSON(jsonlite::toJSON(SubscriptionsAttachmentsObject$type, auto_unbox = TRUE, digits = NA))
        self$`type` <- typeObject
      }
    },
    toJSONString = function() {
      jsoncontent <- c(
        if (!is.null(self$`expression`)) {
        sprintf(
        '"expression":
          "%s"
                ',
        self$`expression`
        )},
        if (!is.null(self$`type`)) {
        sprintf(
        '"type":
        %s
        ',
        jsonlite::toJSON(self$`type`$toJSON(), auto_unbox=TRUE, digits = NA)
        )}
      )
      jsoncontent <- paste(jsoncontent, collapse = ",")
      paste('{', jsoncontent, '}', sep = "")
    },
    fromJSONString = function(SubscriptionsAttachmentsJson) {
      SubscriptionsAttachmentsObject <- jsonlite::fromJSON(SubscriptionsAttachmentsJson)
      self$`expression` <- SubscriptionsAttachmentsObject$`expression`
      self$`type` <- object$new()$fromJSON(jsonlite::toJSON(SubscriptionsAttachmentsObject$type, auto_unbox = TRUE, digits = NA))
      self
    }
  )
)
