% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hca-api.R
\docType{methods}
\name{hca-api-methods}
\alias{hca-api-methods}
\alias{getBundlesCheckout}
\alias{deleteBundle}
\alias{getBundle}
\alias{putBundle}
\alias{postBundlesCheckout}
\alias{putCollection}
\alias{deleteCollection}
\alias{getCollection}
\alias{patchCollection}
\alias{getFile}
\alias{headFile}
\alias{putFile}
\alias{postSearch}
\alias{getSubscriptions}
\alias{putSubscription}
\alias{deleteSubscription}
\alias{getSubscription}
\alias{getBundlesCheckout,HumanCellAtlas-method}
\alias{deleteBundle,HumanCellAtlas-method}
\alias{getBundle,HumanCellAtlas-method}
\alias{putBundle,HumanCellAtlas-method}
\alias{postBundlesCheckout,HumanCellAtlas-method}
\alias{putCollection,HumanCellAtlas-method}
\alias{deleteCollection,HumanCellAtlas-method}
\alias{getCollection,HumanCellAtlas-method}
\alias{patchCollection,HumanCellAtlas-method}
\alias{getFile,HumanCellAtlas-method}
\alias{headFile,HumanCellAtlas-method}
\alias{putFile,HumanCellAtlas-method}
\alias{postSearch,HumanCellAtlas-method}
\alias{getSubscriptions,HumanCellAtlas-method}
\alias{putSubscription,HumanCellAtlas-method}
\alias{deleteSubscription,HumanCellAtlas-method}
\alias{getSubscription,HumanCellAtlas-method}
\title{HCA API methods}
\usage{
getBundlesCheckout(checkout_job_id, ...)
deleteBundle(uuid, ...)
getBundle(uuid, ...)
putBundle(uuid, ...)
postBundle(uuid, ...)
postBundlesCheckout(uuid, ...)
putCollection(uuid, ...)
deleteCollection(uuid, ...)
getCollection(uuid, ...)
patchCollection(uuid, ...)
getFile(uuid, ...)
headFile(uuid, ...)
putFile(uuid, ...)
postSearch(replica, ...)
getSubscriptions(replica, ...)
putSubscription(replica, ...)
deleteSubscription(replica, ...)
getSubscription(replica, ...)

\S4method{getBundlesCheckout}{HumanCellAtlas}(hca, checkout_job_id,
  replica = c("aws", "gcp", "azure"))

\S4method{deleteBundle}{HumanCellAtlas}(hca, uuid, replica = c("aws",
  "gcp", "azure"), version = NULL, reason = NULL)

\S4method{getBundle}{HumanCellAtlas}(hca, uuid, replica = c("aws", "gcp",
  "azure"), version = NULL, directurls = NULL, presignedurls = FALSE,
  token = NULL)

\S4method{putBundle}{HumanCellAtlas}(hca, uuid, replica = c("aws", "gcp",
  "azure"), version = NULL, creator_uid, files)

\S4method{postBundlesCheckout}{HumanCellAtlas}(hca, uuid,
  replica = c("aws", "gcp", "azure"), destination = NULL,
  email = NULL)

\S4method{putCollection}{HumanCellAtlas}(hca, uuid, replica = c("aws",
  "gcp", "azure"), version, contents, description, details, name)

\S4method{deleteCollection}{HumanCellAtlas}(hca, uuid, replica = c("aws",
  "gcp", "azure"))

\S4method{getCollection}{HumanCellAtlas}(hca, uuid, replica = c("aws",
  "gcp", "azure"), version = NULL)

\S4method{patchCollection}{HumanCellAtlas}(hca, uuid, replica = c("aws",
  "gcp", "azure"), version, add_contents, description, details, name,
  remove_contents)

\S4method{getFile}{HumanCellAtlas}(hca, uuid, replica = c("aws", "gcp",
  "azure"), token = NULL, version = NULL)

\S4method{headFile}{HumanCellAtlas}(hca, uuid, replica = c("aws", "gcp",
  "azure"), version = NULL)

\S4method{putFile}{HumanCellAtlas}(hca, uuid, creator_uid, source_url,
  version = NULL)

\S4method{postSearch}{HumanCellAtlas}(hca, replica = c("aws", "gcp",
  "azure"), output_format = c("summary", "raw"), es_query = NULL,
  per_page = 100, search_after = NULL, json = NULL)

\S4method{getSubscriptions}{HumanCellAtlas}(hca, replica = c("aws",
  "gcp", "azure"))

\S4method{putSubscription}{HumanCellAtlas}(hca, replica = c("aws", "gcp",
  "azure"), attachments, callback_url, encoding, es_query, form_fields,
  hmac_key_id, hmac_secret_key, method, payload_form_field)

\S4method{deleteSubscription}{HumanCellAtlas}(hca, uuid,
  replica = c("aws", "gcp", "azure"))

\S4method{getSubscription}{HumanCellAtlas}(hca, uuid, replica = c("aws",
  "gcp", "azure"))
}
\arguments{
\item{checkout_job_id}{character(1). A RFC4122-complliant ID for the checkout
job request.}

\item{replica}{character(1). A replica to fetch form. Can either be
set to "aws", "gcp", or "azure".  DEFAULT is "aws".}

\item{uuid}{character(1). A RFC4122-compliant ID for the bundle.}

\item{version}{character(1). Timestamp of bundle creation in RFC3339.}

\item{reason}{character(1). User-friendly reason for the bundle or timestamp-
specific bundle deletion.}

\item{directurls}{logical(1). Include direct-access URLs in the response.
This is mutually exclusive with the \code{presignedurls} parameter.  DEFAULT
is \code{NULL}.}

\item{presignedurls}{logical(1). Include presigned URLs in the response. This
is mutually exclusive with the directurls parameter.}

\item{token}{\code{Token}. Token to manage retries. End users constructing
queries should not set this parameter. Use \code{get_token()} to generate.}

\item{creator_uid}{character(1). User ID who is creating this bundle.}

\item{files}{list. (ADD DESCRIPTION ON STRUCTURE OF THIS ARGUMENT)}

\item{destination}{character(1). User-owned destination storage bucket.}

\item{email}{character(1). An email address to send status updates to.}

\item{contents}{list. A list of objects describing links to files, bundles,
other collections, and metadata fragments that are part of the collection.}

\item{description}{character(1). A long description of the collection,
formatted in Markdown.}

\item{details}{list. Supplementary JSON metadata for the collection.
(ADD DESCRIPTION OF STRUCTURE)}

\item{name}{character(1). A short name identifying the collection.}

\item{add_contents}{list. List of items to remove from the collection. Items
must match exactly to be removed. Items not found in the collection are
ignored. (ADD DESCRIPTION OF LIST OBJECT)}

\item{source_url}{character(1). Cloud URL for source data.}

\item{output_format}{character(1). Specifies the output format. Either
"summary" or "raw". The default format, "summary", is a list of UUIDs for
bundles that match the query. Set this parameter to "raw" to get the
verbatim JSON metadata for bundles that match the query.}

\item{es_query}{list. Elasticsearch query. (ADD DESCRIPTION OF STRUCTURE)}

\item{per_page}{numeric(1). Max number of results to return per page.}

\item{search_after}{character(1). **Search-After-Context**. An internal state
pointer parameter for use with pagination. The API client should not need to
set this parameter directly; it should instead directly fetch the URL given
in the "Link" header.}

\item{attachments}{list. The set of bundle metadata items to be included in
the payload of a notification request to a subscriptionendpoint. Each
property in this object represents an attachment to the notification
payload. Each attachment will be a child property of the "attachments"
property of the payload. The name of such a child property can be chosen
freely provided it does not start with an underscore. For example, if the
subscription is ``` { "attachments": { "taxon": { "type": "jmespath",
"expression": "files.biomaterial_j
son.biomaterials[].content.biomaterial_core.ncbi_taxon_id[]" } } } ``` the
corresponding notification payload will contain the following entry ```
"attachments": { "taxon": [9606, 9606] } ``` If a general error occurs
during the processing of attachments, the notification will be sent with
`attachments` containing only the reserved `_errors` attachment containing a
string describing the error. If an error occurs during the processing of a
specific attachment, the notification will be sent with all
successfully processed attachments and additionally
the `_errors` attachment containing an object with one
property for each failed attachment. For example, ```
"attachments": { "taxon": [9606, 9606] "_errors" {
"biomaterial": "Some error occurred" } } ``` The value
of the `attachments` property must be less than or
equal to 128 KiB in size when serialized to JSON and
encoded as UTF-8. If it is not, the notification will
be sent with "attachments": { "_errors": "Attachments
too large (131073 bytes)" }}

\item{callback_url}{character(1).
The subscriber's URL. An HTTP request is made to the
specified URL for every attempt to deliver a
notification to the subscriber. If the HTTP response
code is 2XX, the delivery attempt is considered
successful and no more attemtpts will be made.
Otherwise, more attempts will be made with an
exponentially increasing delay between attempts, until
an attempt is successful or the a maximum number of
attempts is reached.}

\item{encoding}{character(1). The MIME type describing the encoding of the
request body.  Either "application/json" or "multipart/form-data".}

\item{form_fields}{list. A collection of static form fields to be supplied in
the request body, alongside the actual notification payload.}

\item{hmac_secret_key}{character(1). The key for signing requests to the
subscriber's URL. The signature will be constructed according to
https://tools.ietf.org/html/draft-cavage-http-signatures and transmitted in
the HTTP `Authorization` header.}

\item{method}{The HTTP request method to use when delivering a notification
to the subscriber.}

\item{payload_form_field}{character(1). The name of the form field that will
hold the notification payload when the request is made. If the default name
of the payload field collides with that of a field in `form_fields`, this
porperty can be used to rename the payload and avoid the collision. This
property is ignored unless `encoding` is `multipart/form-data`.}

\item{hmac-key-id}{character(1). An optional key ID to use with
"hmac_secret_key".}

\item{remove-contents}{list. List of items to remove from the collection.
Items must match exactly to be removed. Items not found in the collection
are ignored.}
}
\description{
Methods to access the Human Cell Atlas's Data Coordination Platform (HCA DCP)
by means of the platform's REST API.

Check the status of a checkout request
}
\author{
Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk

Daniel Van Twisk
}
